[{"categories":null,"contents":"Overview The Graphical Language Server Platform (GLSP) is a client-server framework for building web-based diagram editors. It follows an architectural pattern similar to the hugely popular Language Server Protocol, but applies it to graphical modeling and diagram editors. With that, GLSP enables the development of modern, web-based diagram editors, whereas the heavy lifting, such as loading, interpreting, and editing diagrams according to the rules of the graphical diagram language, is encapsulated in the server.\nA GLSP Server is a standalone backend process and provides the language-specific smarts and editing capabilities. It communicates with a GLSP Client via action messages over JSON-RPC. Actions are plain JSON objects and describe the information needed to execute certain operations. Both the GLSP server and GLSP client have dedicated action handlers that can process incoming action messages.\nEach running diagram widget is considered to be a single GLSP client. Each client is handled by exactly one GLSP server. A GLSP server can handle multiple GLSP clients, each within a dedicated client session.\nThe server is responsible for loading the model source, e.g. a file, EMF model, or database, into the model state and defines how to transform it into the graphical model. The graphical model is a serializable description of the diagram that should be visualized. It is the central communication artifact that is transferred to the client.\nThe GLSP client itself doesn’t need to know how the diagram has been generated from a model source or how to manipulate it. Its main responsibility is to visualize the graphical model and to provide user interface elements for user interaction, such as editing tools. Thus, the client interprets the graphical model received from the server and renders a diagram from it. In addition, the GLSP client handles user interaction and provides editing tools to invoke manipulations of the diagram. While such editing tools are applied by the user, it also shows visual feedback for guiding the user through editing operations.\n  Certain knowledge about the rules of the graphical language is required within client-side editing tools and visual feedback. For instance, the client-side tools need to know whether the user is allowed to connect certain nodes with each other, whether those nodes can be resized or moved between container nodes, etc. Therefore, the protocol between client and server provides dedicated action messages that allows to transfer this required context- and diagram-specific information between the server and the client.\nOnce an editing tool is applied in the client, the client sends a notification to the server, which then will perform the operation on the original model source, regenerates the graphical model and updates the client with the new version of the graphical model, which in turn will then update the rendered diagram based on the new graphical model. \nAction Protocol The GLSP action protocol defines the message types that are exchanged between client and server. The protocol is structured into so-called features. A feature describes a specific diagram capability, e.g. element creation, diagram validation, etc. Each feature is composed of a set of actions and/or operations. An operation is a special subtype of an action and is used to describe actions that modify the underlying model source on the GLSP server. Every action that modifies the model in any way has to be implemented as an operation.\nA detailed description of the protocol is available in the GLSP repository. The action protocol is customizable and can even be extended with additional custom actions using the dependency injection approach (see Dependency Injection) \nAction Dispatching \u0026amp; Handling  Action messages are used for client-server communication. In addition, they are also used for the internal event flow in both the GLSP server and the GLSP client. The action dispatcher is the central component that manages all sent or received actions. For each action type, one or more dedicated handlers can be registered.\nWhen the dispatcher receives a new action for dispatching, it determines whether it should be dispatched to the internal action handlers only or submitted to the opposite component via JSON-RCP (server or client), based on the registered handlers on the server or the client.\nThe dispatcher distinguishes between notifications and request-response action pairs. Notification actions are one-way actions transferred between client and server. This means when the action dispatcher dispatches a notification it does not wait for a response and directly continues with dispatching the next incoming action. Request actions are issued by the GLSP client and can be used to block client-side action dispatching until the server has sent a corresponding response action. For more details on how to implement action handlers see Action \u0026amp; Action Handler. \nDependency Injection As diagram editors are by nature very specific to the respective diagram language, GLSP is designed with a strong focus on customization and extensibility. To this end, both the client and the server are using an inversion of control pattern based on dependency injection (DI). Every service and component that is part of a GLSP interaction is configured in a global DI container. Adopters can simply modify this global DI container and bind additional services or even rebind existing services to customized versions of it.\nGLSP Client Each single diagram widget – that is each client – has its own isolated DI container. All services used by the client, such as action handlers, views, mouse listeners, etc., are configured in this DI container. On the client, GLSP adopts inversify.js as dependency injection framework. With Inversify, a DI container is constructed by loading a set of DI modules into a DI container. Each DI module provides the bindings for a specific feature or concern. Adopters can load new modules into the DI container.\n GLSP Server Similar to the GLSP client, also the server is configured via DI, including its service implementations, handlers, etc. The main difference to the client is, however, that the server has to manage multiple diagram client sessions. Therefore the DI setup is composed of multiple DI containers:\n  Server DI Container  The server DI container is used to configure global components and services that are not related to a specific session diagram as well as components that are shared between all session containers. Diagram Session DI Containers  Each client session has a dedicated DI container which holds the session-specific information as well as dedicated instances of handlers, states, etc. Each client session container is associated with a single diagram language and is configured with the corresponding diagram module.  The Java-based GLSP server uses Google Guice as a dependency injection framework. With Google Guice, there is one main DI module that contains each binding in a dedicated method. Adopters can extend this module and customize it by overriding dedicated binding methods.\nThe node-based GLSP server uses inversify.js as dependency injection framework and is structured similarly to the GLSP client. \nGraphical Model The graphical model is a serializable description of the diagram to be visualized on the client. It is the central communication artifact between client and server. The server creates the graphical model from an arbitrary model source and sends it to the client. Thus, the client doesn’t need to know where it came from and how to manipulate it. However, the client interprets the graphical model in order to render a visualization of the diagram described in the graphical model.\nThe graphical model is composed of nodes and edges. Each element, whether it is a node or an edge, has a unique ID and a type. The graphical model elements are organized in a tree, as defined by the parent-child relationship between elements.\nThe graphical model is typically composed of the following elements. However, these base classes can be extended by adopters, e.g. to be augmented with new custom element types and properties (see Extending the Graphical Model).\n GModelRoot: Each graphical model must have exactly one root  GShapeElement: A graphical element is represented by a shape with visual bounds (position and size). Note that such elements can be nested based on their parent-child relationship. There are a the following concrete sub-types of shapes:  GNode: Representation of a logical diagram node GPort: Ports are typically children of nodes and serve as connection points for edges GLabel: Representation of a text label GCompartment: A generic container element used for element grouping   GEdge: A diagram edge that connects a source element and a target element (typically nodes or ports).     SModel: Graphical model on client side The default GLSP client uses Sprotty, an SVG-based diagramming framework, to render diagrams. Sprotty uses a model to represent a diagram too \u0026ndash; the so-called SModel. The graphical model of GLSP is based on the SModel and, thus, can be seen as a compatible extension of the Sprotty model.\nAs a naming convention, GLSP uses the S-prefix for model elements on the client to conform to the naming of the Sprotty model. Thus, a node of the graphical model on the GLSP client is called SNode, whereas it is called GNode on the server, the same is true for SEdge/GEdge, etc. Semantically, those elements, however, are equivalent and are exchanged transparently between the server and the client via JSON-RPC. \nGModel: Graphical model on server side The Java-based GLSP server uses the Eclipse Modeling Framework (EMF) to represent and manage the graphical model internally. Note that this is just an internal way of representing the GModel at runtime but doesn’t mean that adopters need to represent their original source models with EMF too. The GLSP server uses EMF in order to reuse its model management and editing capabilities, its command stack and command-based editing. Therefore, the graphical model is described as an Ecore model and the corresponding Java classes are automatically generated from this model. Using GSON, the GModel is then serialized and deserialized to JSON before it is sent via JSON-RPC to the client.\nThe node-based GLSP server uses the same representation of the GModel as the client, since both are based on ES6. \nPlatform Integrations GLSP-based editors can be integrated into any web application frame. To ease the platform integration for adopters, however, dedicated glue code frameworks are provided for\n Creating an extension to provide a GLSP editor for Eclipse Theia Creating an extension to provide a GLSP editor for VSCode Creating a plugin to prove a GLSP editor for the Eclipse IDE Creating a standalone GLSP web editor based on plain javascript  In general it is recommended to keep the GLSP diagram implementation separated from the platform integration code by splitting them into separate packages. With that, the core GLSP editor can be easily reused and integrated into another platform.\nAs an example, the GLSP Workflow example provides the GLSP diagram implementation in the @eclipse-glsp/workflow-glsp package. All platform specific integration examples import this package and provide a small integration package containing the platform-specific glue code on top.\n","permalink":"https://www.eclipse.org/glsp/documentation/architecture/","tags":null,"title":"Overview \u0026 Architecture"},{"categories":null,"contents":"To be able to render the diagram, the GLSP client first requests the graphical model from the server. The model loading process is initiated with a RequestModelAction. Typically this is the first action that the GLSP client sends after initializing the diagram widget.\nWith the RequestModelAction, the client can provide a set of custom arguments (client options). At the bare minimum these client options have to provide the required information so that the GLSP server can identify and load the correct model source. In most cases this will be, for instance, a URI of the model to be loaded.\nTo handle such a request model action, the GLSP server will perform the following steps:\n Invoke the configured ModelSourceLoader to load the model from an arbitrary model source into the model state. Invoke the configured GModelFactory to transform the model state into the graphical model (GModel; see GModelFactory) that describes the diagram to be rendered. Invoke the model submission to send the graphical model to the client.  In this section, we’ll look at step 1, in which the configured ModelSourceLoader implementation is invoked to load the source model from the arbitrary model source into the model state.\nThe ModelState is the central stateful object within a client session that represents the information about the current state of the original source model. All other services and handlers may access the model state to obtain the required information about the model in order to perform their respective tasks.\nAs you typically need to store custom information that is specific to your model in the model state, you typically also bind a custom implementation that represents your model state. This implementation usually implements the interface GModelState (and extends the base class DefaultGModelState).\nJava GLSP Server protected Class\u0026lt;? extends GModelState\u0026gt; bindGModelState() { return MyModelState.class; }  Node GLSP Server protected configure(bind: interfaces.Bind, unbind: interfaces.Unbind, isBound: interfaces.IsBound, rebind: interfaces.Rebind): void { super.configure(bind, unbind, isBound, rebind); bind(MyModelState).toSelf().inSingletonScope(); bind(ModelState).toService(MyModelState); }   Now as we have registered our model state implementation, we can look at the model source loading. First, we need to make the GLSP server aware of your model source loader, you have to register your implementation of the ModelSourceLoader interface in the server’s DI module:\nJava GLSP Server @Override protected Class\u0026lt;? extends ModelSourceLoader\u0026gt; bindSourceModelLoader() { return MyModelLoader.class; }  Node GLSP Server protected configure(bind: interfaces.Bind, unbind: interfaces.Unbind, isBound: interfaces.IsBound, rebind: interfaces.Rebind): void { super.configure(bind, unbind, isBound, rebind); bind(ModelSourceLoader).to(MyModelLoader); }   The registered implementation of the model loader needs to load the source model and add it to the session’s model state, based on the parameters that are contained in the RequestModelAction. Consequently, the implementation mostly depends on where you need to load your source model(s) from and what kind of model(s) you are dealing with (files, XML, JSON, EMF, database, etc.).\nJava GLSP Server public class MyModelLoader implements ModelSourceLoader { @Inject protected MyModelState modelState; @Override public void loadSourceModel(final RequestModelAction action) { final String uri = MapUtil.getValue(action.options, \u0026#34;sourceURI\u0026#34;); // load your model from file, EMF, database, etc.  final YourModel model = …; // add information needed about your model into the model state  modelState.setModel(model); } }  Node GLSP Server @injectable() export class MyModelLoader implements ModelSourceLoader { @inject(MyModelState) protected modelState: MyModelState; loadSourceModel(action: RequestModelAction): MaybePromise\u0026lt;void\u0026gt; { const uri = action.options![\u0026#34;sourceURI\u0026#34;]; // load your model from file, EMF, database, etc.  const model = …; // add information needed about your model into the model state  this.modelState.model=model; } }   In the GLSP Workflow example there is also an example, in which the source model is a JSON file that contains the GModel directly. In such a scenario, you can use the plain GModelState and the JsonFileGModelLoader.\nOnce the source model has been loaded into the model state, the GLSP server invokes the configured GModelFactory to derive the graphical model from the source model and issues model update for the client. (see Graphical Model Generation)\n","permalink":"https://www.eclipse.org/glsp/documentation/modelloading/","tags":null,"title":"Model Source \u0026 State"},{"categories":null,"contents":"After the initial loading of the source model – and also after each change of the original source model – the GLSP server generates a graphical model from the source model in order to define what is to be rendered on the client.\nThe generation of the graphical model from the original model source is the responsibility of the GModelFactory. Therefore, the GModelFactory obtains the source model from the model state and generates a new graphical model from it. Implementations of the GModelFactory are by nature very specific to the source model and the diagram type. Thus, in almost every GLSP editor project, a custom GModelFactory implementation is provided.\nThe only exception are GLSP editors that directly operate on GModels; that is, the GModel is persisted and loaded directly by the model source loader. In such cases, no transformation from the model source and the GModel needs to be provided as the model source already is the GModel. Thus, the so-called NullImpl of the GModelFactory can be used. An example for such a use case is provided in the GLSP Workflow example.\nFor all other use cases, an implementation of the GModelFactory needs to be provided and registered in the server DI module as follows.\nJava GLSP Server @Override protected Class\u0026lt;? extends GModelFactory\u0026gt; bindGModelFactory() { return MyModelFactory.class; }  Node GLSP Server protected configure(bind: interfaces.Bind, unbind: interfaces.Unbind, isBound: interfaces.IsBound, rebind: interfaces.Rebind): void { super.configure(bind, unbind, isBound, rebind); bind(GModelFactory).to(MyModelFactory).inSingletonScope(); }   For the sake of an example, let’s assume that the model source is a simple list of named entities. Each entity should be visualized as a node with a label, which indicates its name. Then the corresponding ModelFactory could look as follows.\nJava GLSP Server public class MyModelFactory implements GModelFactory { @Inject protected MyModelState modelState; @Override public void createGModel() { List\u0026lt;Entity\u0026gt; entities = modelState.getModel().getEntities(); List\u0026lt;GModelElement\u0026gt; entityNodes = entities.stream().map(entity -\u0026gt; //  new GNodeBuilder(\u0026#34;node:entity\u0026#34;) .layout(\u0026#34;vbox\u0026#34;) .add(new GLabelBuilder() .text(entity.getName()) .build()) .build()) .collect(Collectors.toList()); GGraph newModel = new GGraphBuilder() .id(\u0026#34;entity-graph\u0026#34;) .addAll(entityNodes) .build(); modelState.setRoot(newModel); } }  Node GLSP Server @injectable() export class MyModelFactory implements GModelFactory { @inject(MyModelState) protected modelState: MyModelState; createModel(): void { const entities = this.modelState.getModel().getEntities(); const entityNodes = entities.map(entity =\u0026gt; new GNodeBuilder(GNode).id(\u0026#39;node:entity\u0026#39;).layout(\u0026#39;vbox\u0026#39;) .add(new GLabelBuilder(GLabel) .text(entity.name) .build()) .build() ); const newModel = new GGraphBuilder(GGraph) .id(\u0026#39;entity-graph\u0026#39;) .addChildren(...entityNodes) .build(); this.modelState.root = newModel; } }   In the createGModel() method the entities are retrieved from the model state, as they have been added there by the model source loader (see Model Source Loader). Then a new GNode is created for each entity. Finally all new nodes are added as children of a newly created GGraph and the graphical root element in the model state is updated.\nNote that we have used the GModelBuilder API in this example to construct new graphical elements. This builder API offers a convenient way to construct new graphical model elements in a concise and fluent fashion. It is the preferred method and should be used over plain constructor creation.\n","permalink":"https://www.eclipse.org/glsp/documentation/modelgeneration/","tags":null,"title":"Graphical Model Generation"},{"categories":null,"contents":"Model Rendering The input of the diagram rendering on the client is the GModel that has been generated on the server from the model source (see Graphical Model Generation) and sent to the client via a SetModelAction or UpdateModelAction. The client is then responsible for rendering the graphical model.\nIn order to render the received graphical model, each graphical element type needs to be associated with a view on the client. A view defines how a specific type of graphical element shall be transformed into a corresponding SVG representation. The derived SVG elements are then rendered on the canvas of the diagram widget.\nTo define a new view, we have to create a class that implements the IView interface and register it for a specific type that is used in the graphical model. As an example, let’s configure that the view named SLabelView is used for all elements with the type “label:custom”. Therefore, we first need to create a dependency injection module, named customDiagramModule below, and configure the SLabelView for the graphical model element type “label:custom” using the configureModelElement() utility function:\nconst customDiagramModule= new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;label:custom\u0026#39;, SLabel, SLabelView); }); The configureModeElement() function takes the inversify binding context, the graphical model type, its model class and its associated view as input. Under the hood this function sets up the necessary bindings so that the GLSP client knows that\n Graphical model elements (received from the GLSP Server) with type ‘label:custom’ are deserialized to instances of SLabel Graphical model element with type ‘label:custom’ are rendered with the SLabelView  In order to be effective, we need to load the module customDiagramModule defined above in the diagram DI container, aka the root \u0026ldquo;di.config.ts\u0026rdquo; of your diagram implementation. With that, every element of type “label:custom” will be rendered with the view implementation SLabelView.\nViews themselves are typically implemented with JSX, which simplifies the definition of SVG elements in Typescript. Therefore, the following generic imports are required in any module declaring a view to enable declaration of svg elements with JSX:\n/** @jsx svg */ import { VNode } from \u0026#39;snabbdom\u0026#39;; import { RenderingContext, svg } from ‘@eclipse-glsp/client’; In addition, make sure that the following options are set in the tsconfig.json file of your project:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;jsx\u0026#34;:\u0026#34;react\u0026#34;, \u0026#34;reactNamespace\u0026#34;:\u0026#34;JSX\u0026#34; } With that, we can implement a view as follows:\n@injectable() export class SLabelView extends ShapeView { render(label: Readonly\u0026lt;SLabel\u0026gt;, context: RenderingContext): VNode | undefined { if (!isEdgeLayoutable(label) \u0026amp;\u0026amp; !this.isVisible(label, context)) { return undefined; } const vnode = \u0026lt;text class-sprotty-label={true}\u0026gt;{label.text}\u0026lt;/text\u0026gt;; const subType = getSubType(label); if (subType) { setAttr(vnode, \u0026#39;class\u0026#39;, subType); } return vnode; } } Every view has to implement the render() method. The render() method takes the graphical model element as input and returns the corresponding SVG element as virtual DOM node. The viewer queries all registered views and creates a new virtual DOM which is then used to patch the current DOM of the diagram widget.\nNote that the SLabelView also checks whether the given element is visible and skips the SVG generation if the element is not visible in the diagram canvas. This check is optional but it’s highly recommended to implement it in your custom views as it heavily improves the rendering performance. \nStyling The style of the rendered SVG elements is controlled with plain CSS. CSS classes can be declared directly in the corresponding view. The SLabelView, for instance, adds the CSS class ‘sprotty-label’ to the generated SVG text element.\nconst vnode = \u0026lt;text class-sprotty-label={true}\u0026gt;{label.text}\u0026lt;/text\u0026gt;; Graphical model elements also have a ‘cssClasses’ property which contains a list of CSS classes to be applied, in addition to the classes defined in the view. For instance, the server could send the following graphical model element:\n{ \u0026#34;id\u0026#34;: \u0026#34;myCustomLabel\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;label:custom\u0026#34;, \u0026#34;cssClasses\u0026#34;:[ \u0026#34;my-custom-class\u0026#34; ] } Keeping our previous model configuration in mind, the corresponding SVG element now has two css classes applied: ‘sprotty-label’ and ‘my-custom-class’.\nBased on those CSS classes, we can define CSS rules:\n.sprotty-label { fill: black; font-size: 100%; } .my-custom-class.sprotty-label { fill: red; } This simple style sheet declares that elements with the class ‘sprotty-label’’ should be rendered in black. If “my-custom-class’’ is applied as well they are rendered in red. To load this stylesheet it has to be imported somewhere in the project. Typically this is done in the \u0026ldquo;di.config.ts” file as it’s the entry point of the diagram DI container.\nimport \u0026#39;../css/diagram.css\u0026#39;; const customDiagramModule= new ContainerModule((bind,unbind, isBound,rebind)=\u0026gt;{ … }); ","permalink":"https://www.eclipse.org/glsp/documentation/rendering/","tags":null,"title":"Model Rendering \u0026 Styling"},{"categories":null,"contents":"We distinguish between micro and macro layout. Usually, the server is responsible for the macro layout, that is the arrangement of the main model elements (i.e. nodes and edges). This layout is defined already in the graphical model by means of coordinates. In turn, the client is responsible for the micro layout, that is the positioning and size computation of elements within a container element such as nodes. The client side (i.e. micro) layout can be configured in the graphical model, but will be applied on the client during the rendering phase. \nLayout Container Graphical elements that support client-side layouting of contained elements offer a layout property which defines the type of layouter that should be used. In addition, the behavior of the layouter can be configured with layout options.\nFor an example let’s have a look at the following GNode:\n Java GLSP Server new GNodeBuilder() .layout(\u0026#34;vbox\u0026#34;) .layoutOptions(new GLayoutOptions() .hAlign(\u0026#34;center\u0026#34;)) .add(new GLabelBuilder() .text(\u0026#34;label1\u0026#34;) .build()) .add(new GLabelBuilder() .text(\u0026#34;label2\u0026#34;) .build()) .build();   Node GLSP Server GNode.builder() .layout(\u0026#39;vbox\u0026#39;) .addLayoutOption(\u0026#39;hAlign\u0026#39;, \u0026#39;center\u0026#39;) .add(new GLabelBuilder(GLabel).text(\u0026#39;label1\u0026#39;).build()) .build();   This node contains two label elements that should be layouted. There are four built-in layout types that can be used: “hbox”,”vbox”,”stack” and “freeform”. In the example node we define that the labels should be layouted with the vbox layouter. In addition, we specify options for that layouter by defining that the children should be centered horizontally.\nAdditional layouters can be contributed by creating a layouter class that implements the ILayout interface.\nGLSP Client export interface ILayout { layout(container: SParentElement \u0026amp; LayoutContainer, layouter: StatefulLayouter): void }  Then the new custom layout needs to bound in the diagram module (\u0026ldquo;di.config.ts\u0026rdquo;):\nGLSP Client const myDiagramMdoule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { bind(TYPES.Layouter).to(MyCustomLayouter); }   Edge Layout Graphical elements that are typically rendered in combination with an edge such as labels have an edgeLayout property. This can be used to describe how the element should be aligned with the edge.\nFor example let\u0026rsquo;s have a look at the following GLabel:\n Java GLSP Server new GLabelBuilder() //  .edgePlacement(new GEdgePlacementBuilder()//  .side(\u0026#34;top\u0026#34;)//  .position(0.5)//  .build())//  .add(new GLabelBuilder().text(\u0026#34;MyLabel\u0026#34;).build()) .build();   Node GLSP Server GLabel.builder() .edgePlacement({ side: \u0026#39;top\u0026#39;, position: 0.5, rotate: false, offset: 0 }) .add(new GLabelBuilder(GLabel).text(\u0026#39;MyLabel\u0026#39;).build()) .build();   The label above specifies the property edgePlacement. If this label is added as a child of an edge, it will be placed above the edge. The position is defined with 0.5 (i.e. 50 percent of the edge length) which means the label should be placed in the center of the edge. After the edge routes have been rendered the client will query all active edge placements and adjust the label position accordingly.\n","permalink":"https://www.eclipse.org/glsp/documentation/clientlayouting/","tags":null,"title":"Client-side layouting"},{"categories":null,"contents":"GLSP provides a set of default graphical model element classes that can be used to construct the graphical model and already cover a large set of use cases. For advanced use cases the existing base model elements can be customized or additional elements can be introduced. As an example, let’s have a look at the custom WeightedEdge element introduced by the GLSP Workflow example.\nGLSP Client A WeightedEdge is a special edge that has an optional “probability” property. We can define such an element by simply subclassing the SEdge class:\nexport class WeightedEdge extends SEdge { probability?: string; } And then the new WeightedEdge type has to be configured in the diagram module (di.config.ts).\nconst workflowDiagramModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... configureModelElement(context, \u0026#39;edge:weighted\u0026#39;, WeightedEdge, WorkflowEdgeView); ... }  Node GLSP Server For the node GLSP server the new WeightedEdge type can be declared similar to the GLSP client by subclassing the GEdge class.\nexport class WeightedEdge extends GEdge { probability?: string; } To use the builder API for WeightedEdge creation we also have to implement a WeightedEdgeBuilder that extends the default GEdgeBuilder.\nexport class WeightedEdgeBuilder\u0026lt;E extends WeightedEdge = WeightedEdge\u0026gt; extends GEdgeBuilder\u0026lt;E\u0026gt; { probability(probability: string): this { this.proxy.probability = probability; return this; } }  Java GLSP Server When using the Java GLSP server, a new Ecore model that extends the default \u0026ldquo;graph.ecore\u0026rdquo; model has to be created to declare new model elements. For more details, please have a look at the \u0026ldquo;workflow-graph.ecore\u0026rdquo; model in the GLSP Workflow example. Once the WeightedEdge is specified in the Ecore model, the corresponding source code has to be generated. Now the GraphExtension API can be used to configure the \u0026ldquo;workflow-graph.ecore\u0026rdquo; for the workflow diagram language. A class that implements the the corresponding interface has to created:\npublic class WFGraphExtension implements GraphExtension { @Override public EPackage getEPackage() { return WfgraphPackage.eINSTANCE; } @Override public EFactory getEFactory() { return WfgraphFactory.eINSTANCE; } } And then configured in the WorkflowDiagramModule:\n@Override protected Class\u0026lt;? extends GraphExtension\u0026gt; bindGraphExtension() { return WFGraphExtension.class; } To use the builder API for WeightedEdge creation we also have to implement a WeightedEdgeBuilder that extends the default AbstractGEdgeBuilder. \nGeneric Args Every graphical model element type has a generic “args” property, which can be used to store additional properties as key-value pairs. These arguments can be used as a more lightweight alternative to extending the graphical model classes, especially if only simple extensions are needed.\n","permalink":"https://www.eclipse.org/glsp/documentation/modelextension/","tags":null,"title":"GModel Extensions"},{"categories":null,"contents":"Validation rules for the source and/or graphical model are typically implemented on the GLSP server, as only the server has the full knowledge of the underlying model. Model validation rules are by nature specific to the underlying modeling language and therefore have to be provided by the specific server implementation. The interface to be implemented is called ModelValidator. The ModelValidator is invoked for a set of model elements and creates issue markers for them.\nIn many scenarios, the ModelValidator implementation delegates to another component, such as EMF validation, etc.\nLet\u0026rsquo;s have a look at a simple example implementation of a model validator:\nJava Server public class CustomModelValidator implements ModelValidator { @Override public List\u0026lt;Marker\u0026gt; validate(final GModelElement... elements) { List\u0026lt;Marker\u0026gt; markers = new ArrayList\u0026lt;\u0026gt;(); for (GModelElement element : elements) { if (element instanceof GNode) { markers.add(validateGNode((GNode) element)); } element.getChildren().forEach(child -\u0026gt; markers.addAll(validate(child))); } return markers; } protected Marker validateGNode(final GNode element) { return new Marker(\u0026#34;Node\u0026#34;, \u0026#34;This graphical element is a node\u0026#34;, element.getId(), MarkerKind.INFO); } }  Node Server @injectable() export class CustomModelValidator implements ModelValidator { @inject(GModelState) protected readonly modelState: GModelState; validate(elements: GModelElement[]): Marker[] { const markers: Marker[] = []; for (const element of elements) { if (element instanceof GNode) { markers.push(this.validateGNode(element)); } if (element.children) { markers.push(...this.validate(element.children)); } } return markers; } protected validateGNode(element: GNode): Marker { return { kind: MarkerKind.INFO, description: \u0026#39;This graphical element is a node\u0026#39;, elementId: element.id, label: \u0026#39;Node\u0026#39; }; } }   This validator iterates over the given model elements and their children and creates a new info marker for each element that is an instance of GNode. An issue marker is associated with a graphical element via its “id”. In addition, the marker has a label, an issue description and a kind indicating its severity. The severity can either be “INFO”,”WARN” or “ERROR”. The created markers are then propagated to the client via a SetMarkersAction.\nTo enable the custom model validator, it has to be bound in the diagram module.\nJava Server @Override protected Class\u0026lt;? extends ModelValidator\u0026gt; bindModelValidator() { return CustomModelValidator.class; }  Node Server protected configure(bind: interfaces.Bind, unbind: interfaces.Unbind, isBound: interfaces.IsBound, rebind: interfaces.Rebind): void { super.configure(bind, unbind, isBound, rebind); bind(ModelValidator).to(CustomModelValidator).inSingletonScope(); }   Validation is typically triggered by the client via a RequestMarkersAction – e.g., by clicking the validation button in the tool palette. In addition, the server can also send a SetMarkersAction to the client without a preceding request at any time. This is useful to implement features such as automatic live validation after each model update.\nThe client visualizes each marker by decorating the corresponding graphical element with an icon indicating the severity. When hovering over the issue marker a tooltip with the issue description is displayed.\nDepending on the chosen platform integration, validation markers are propagated to other user interface components. For instance, when integrating GLSP into Theia, markers are also translated into items shown in the Problems view.\n","permalink":"https://www.eclipse.org/glsp/documentation/validation/","tags":null,"title":"Model Validation"},{"categories":null,"contents":"Action messages are used for client-server communication. In addition, they are also used for the internal event flow in both the GLSP server and the GLSP client. Actions must be handled by at least one or more action handlers. Any service, mouse or keyboard tool, etc. can issue actions by invoking the action dispatcher, either on the client or the server. The action dispatcher – there is one on the client and one on the server – is the central component responsible for dispatching received actions to their designated action handlers (see also Action Dispatching \u0026amp; Handling).\nAdopters can contribute new action handlers or customize existing handlers for any action types of the action protocol. In addition, the base action protocol can be extended with new action kinds and designated handlers.\nTo do that the following steps have to be performed\n Create a new action specification by providing a corresponding Action implementation Create a new action handler for the newly created action type by providing a implementation of the ActionHandler interface Configure the new action type and handler in the DI module.  Action specification Adopters can declare new custom actions by providing an implementation for the Action interface (resp. base class).\nJava GLSP Server public class MyCustomAction extends Action { public static final String KIND= \u0026#34;myCustomKind\u0026#34;; private String additionalInformation; public MyCustomAction() { super(KIND); } public String getAdditionalInformation() { return additionalInformation; } public void setAdditionalInformation(final String additionalInformation) { this.additionalInformation = additionalInformation; } }  GLSP Client/Node GLSP Server export class MyCustomAction implements Action { static readonly KIND = \u0026#39;myCustomKind\u0026#39;; kind = MyCustomAction.KIND; constructor(public readonly additionalInformation: string) { } }   Each action specification has a unique “kind” and can optionally declare additional data properties We recommend defining the action kind as a static constant of the implementing class so that it can be accessed from other places, e.g. when registering the handler. Note that action instances need to be serializable to JSON. Therefore the class should only contain plain data properties and no additional business logic. In addition, references to graphical model elements should be done by id.\nIf an action is interchanged between client and server both need to provide the corresponding action definition.\nRequest-Response Actions If the client should be able to dispatch the new action as a blocking request, the action specification class has to implement or extend RequestAction.\nJava GLSP Server public class MyCustomRequestAction extends RequestAction\u0026lt;MyCustomResponseAction\u0026gt; { public static final String KIND= \u0026#34;myCustomRequest\u0026#34;; private String additionalInformation; public MyCustomRequestAction() { super(\u0026#34;my.custom.kind\u0026#34;); } public String getAdditionalInformation() { return additionalInformation; } public void setAdditionalInformation(final String additionalInformation) { this.additionalInformation = additionalInformation; } }  GLSP Client/Node GLSP Server export class MyCustomRequestAction implements RequestAction\u0026lt;MyCustomResponseAction\u0026gt; { static readonly KIND = \u0026#39;myCustomRequest\u0026#39;; kind = MyCustomRequestAction.KIND; constructor(public readonly additionalInformation: string, public readonly requestId = \u0026#39;\u0026#39;) {} }   Each request action has a “requestId” and defines its response action as a type parameter. Of course, the response action specification has to be specified as well:\nJava GLSP Server public class MyCustomResponseAction extends ResponseAction { public static final String KIND = \u0026#34;myCustomResponse\u0026#34;; public MyCustomResponseAction() { super(KIND); } }  GLSP Client/Node GLSP Server export class MyCustomResponseAction implements ResponseAction { static readonly KIND = \u0026#39;myCustomResponse\u0026#39;; kind = MyCustomResponseAction.KIND; constructor(public responseId = \u0026#39;\u0026#39;) {} }   The client can dispatch a request action either in blocking fashion awaiting the response:\n@inject(TYPES.IActionDispatcher) protected actionDispatcher: GLSPActionDispatcher; … const response = await this.actionDispatcher.request(new MyCustomRequestAction(“info”)); // response is of type MyCustomResponseAction or simply dispatch the action as non-blocking notification:\n@inject(TYPES.IActionDispatcher) protected actionDispatcher: GLSPActionDispatcher; … this.actionDispatcher.dispatch(new MyCustomRequestAction(“info”)); Response actions don’t necessarily have to be part of a response-request action pair and can also be dispatched without a preceding request action. \nImplementing an Action Handler (GLSP Server) To create a new action handler, a class that implements the ActionHandler interface has to be created. In general, an action handler can handle one or more action kinds. However, handling multiple action kinds is typically reserved for rather uncommon edge cases. Therefore, the Java GLSP server provides an abstract base class that is designed for the single-action-kind-per-hanlder use case.\nJava GLSP Server public class MyCustomActionHandler extends AbstractActionHandler\u0026lt;MyCustomResponseAction\u0026gt; { @Override protected List\u0026lt;Action\u0026gt; executeAction(final MyCustomResponseAction actualAction) { // implement your custom logic to handle the action  // Finally issue response actions  // If no response actions should be issued \u0026#39;none()\u0026#39; can be used;  return listOf(new MyCustomResponseAction()); } }  Node GLSP Server @injectable() export class MyCustomActionHandler implements ActionHandler { actionKinds = [MyCustomRequestAction.KIND]; execute(action: MyCustomRequestAction): MaybePromise\u0026lt;Action[]\u0026gt; { // implement your custom logic to handle the action  // Finally issue response actions  // If no response actions should be issued \u0026#39;[]\u0026#39; can be used;  return [new MyCustomResponseAction()]; } }   The executeAction() method has to be implemented to provide the custom logic of your action handler. It returns a set of response actions that should be dispatched after the handler execution.\nFinally the custom handler has to be configured in the DiagramModule:\nJava GLSP Server protected void configureClientActions(final MultiBinding\u0026lt;Action\u0026gt; binding) { super.configureClientAction(binding); binding.add(MyCustomRequestAction.class); }  Node GLSP Server protected configureClientActions( binding: InstanceMultiBinding\u0026lt;string\u0026gt; ): void { super.configureClientActions(binding); binding.add(MyCustomRequestAction.KIND); }   In addition, each response action of the handler that should be handled by the GLSP client has to be configured as dedicated client action to indicate that it needs to be dispatched to the client:\nJava GLSP Server protected void configureClientActions(final MultiBinding\u0026lt;Action\u0026gt; binding) { super.configureClientAction(binding); binding.add(MyCustomRequestAction.class); }  Node GLSP Server protected configureClientActions( binding: InstanceMultiBinding\u0026lt;string\u0026gt; ): void { super.configureClientActions(binding); binding.add(MyCustomRequestAction.KIND); }   Request-Response Handling Action handlers can treat request-response actions in the same way as plain actions. No special handling is required. The action dispatcher tracks all incoming request actions and automatically intercepts the corresponding response action to set the correct response id. \nImplementing an Action Handler (GLSP Client) On the client, GLSP reuses the IActionHandler API of Sprotty. Therefore, to create a new action handler, a class that implements the IActionHandler interface has to be created.\n@injectable() export class MyCustomResponseActionHandler implements IActionHandler{ handle(action: MyCustomResponseAction): void | Action { // implement your custom logic to handle the action  // Optionally issue a response action  } } The handle() method has to be implemented to provide the custom logic of your action handler. It optionally returns a response action that should be dispatched after the handler execution.\nA dedicated configuration function is available to configure the new action handler in the diagram module (“di.config.ts”):\nconst diagramModule = new ContainerModule((bind, _unbind, isBound, rebind) =\u0026gt; { const context = { bind, _unbind, isBound, rebind }; configureActionHandler(context, MyCustomResponseAction.KIND, MyCustomResponseActionHandler); } The configureActionHandler() function takes the inversify binding context, the action kind that should be handled, and the action handler class, as input. It registers the action handler for the given action kind, so that it can be retrieved by the action dispatcher.\nNote that we don’t have to explicitly declare which actions are handled by the GLSP Server. The GLSP server sends this information during the initialization process and the GLSP client automatically sets up the necessary action (handler) registrations.\n","permalink":"https://www.eclipse.org/glsp/documentation/actionhandler/","tags":null,"title":"Actions \u0026 Action Handler"},{"categories":null,"contents":"Articles  An introduction to the Graphical Language Server Protocol/Platform (Eclipse GLSP) Web-based diagram editor features in Eclipse GLSP GLSP: Diagrams in VS Code, Theia, Eclipse and plain HTML Diagram editors in Theia and VS Code with Eclipse GLSP A diagram editor framework for VS Code A hands-on tutorial for Eclipse GLSP A minimal diagram editor example for Eclipse GLSP Building diagram editors in Eclipse Theia with GLSP The workflow diagram example for Eclipse GLSP A web-based modeling tool based on Eclipse Theia and GLSP  Videos  EclipseCon 2021: Diagram editors with Eclipse GLSP - 1.0 Cloud Tool Time: Diagram editors in Theia and VSCode with Eclipse GLSP EclipseCon 2020: Diagram editors in the web with Eclipse GLSP EclipseCon 2020: Ecore tools in the cloud - behind the scenes EclipseCon 2020: Web-based modeling tools with EMF.cloud and GLSP Eclipse Virtual Meet Up 2019: Diagrams in web and space with GLSP EclipseCon 2019: Diagrams in web and space with GLSP EclipseCon Europe 2018: Towards a Graphical Language Server Protocol for Diagrams?  ","permalink":"https://www.eclipse.org/glsp/documentation/additionals/","tags":null,"title":"More Articles \u0026 Videos"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/categories/","tags":null,"title":"Categories"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/documentation/","tags":null,"title":"Documentation"},{"categories":null,"contents":"An example GLSP diagram including one GLSP server and several diagram client integrations (VS Code, Eclipse Theia, plain HTML and Eclipse desktop IDE). The example can be used to try out the GLSP features in a running version. Most components of GLSP, such as the GLSP server framework or the Theia integration implement the workflow diagram as a consistent example. As the example is fully open source, you can use the example as a blueprint for a custom implementation of a GLSP diagram. The example diagram is a simplified flow chart with different types of nodes and edges (see screen shot below)  To launch/browse the example, please use the links below leading to the components of the workflow diagram example. You will need the workflow GLSP server (there is only one) and at least one client integration (select the one you are interested in). Launch the server first and then the client of your choice to try the example. Alternativly, you can try the workflow example online embedded into an example tool (see last option below) ","permalink":"https://www.eclipse.org/glsp/examples/","tags":null,"title":"Examples"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/gallery/","tags":null,"title":"Gallery"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/","tags":null,"title":"GLSP"},{"categories":null,"contents":"Support for GLSP and for projects adopting GLSP is provided by ","permalink":"https://www.eclipse.org/glsp/support/","tags":null,"title":"Support"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/tags/","tags":null,"title":"Tags"}]