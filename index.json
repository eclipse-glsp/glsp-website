[{"categories":null,"contents":"The Graphical Language Server Platform (GLSP) is a client-server framework for building web-based diagram editors. It follows an architectural pattern similar to the hugely popular Language Server Protocol, but applies it to graphical modeling and diagram editors. With that, GLSP enables the development of modern, web-based diagram editors, whereas the heavy lifting, such as loading, interpreting, and editing diagrams according to the rules of the graphical diagram language, is encapsulated in the server. Consequently, diagram editors can easily be integrated with multiple tool platforms, such as VS Code, Eclipse Theia, Eclipse RCP, and in standalone or web apps.\nA GLSP Server is a separate backend process and provides the language-specific smarts and editing capabilities. It communicates with a GLSP Client over JSON-RPC with an extensible action protocol. Each application has one GLSP client. A GLSP client can have multiple sessions, whereas each session represents a single diagram editor instance. Each client is handled by exactly one GLSP server. A server can handle multiple clients, each within a dedicated client session.\nHow it works The GLSP server is responsible for loading an arbitrary source model, e.g. a JSON file, EMF model, or database, and defines how to transform it into the graphical model. The graphical model is a serializable description of the diagram to be rendered on the client. It is the central communication artifact that is transferred to the client.\nThe GLSP client receives the graphical model as input and renders it. Additionally, the client requests information on editing operations that can be applied in the context of the graphical model. Based on this information, the client can provide the editing tools for making changes to the diagram, such as moving elements, adding nodes or edges, changing labels, etc.\nOnce a user performs a change in the diagram, the client sends a notification to the server. The server then applies the operation back to the source model, regenerates the graphical model and updates the client with the new version of the graphical model. The client will then update the rendered diagram based on the new graphical model it received.\nCustomization and Extension As diagram editors are by nature very specific to the respective diagram language, GLSP is designed with a strong focus on customizability and extensibility. To this end, GLSP applies two principles:\n Dependency Injection Both the client and the server are using an inversion of control pattern based on dependency injection (DI) with inversify.js and Guice. Every service and component is configured in a global DI container and can simply be extended or even replaced with a custom implementation. Adopters consequently have the same power for their diagram editors, as the framework authors. Slim abstractions and direct access to the underlying technologies Especially, when it comes to the look \u0026amp; feel of a diagram editor, it is crucial to have full control over the rendering and the UI. Therefore, GLSP gives full access and control over the underlying UI technologies, such as Eclipse Sprotty, SVG and CSS, editing tools, user interface controls (HTML), without abstraction layers where control matters. Avoiding abstraction layers also enables an excellent debugging experience.  ‚û°Ô∏è Now it is time to get started!\n","permalink":"https://www.eclipse.org/glsp/documentation/overview/","tags":null,"title":"Overview"},{"categories":null,"contents":"GLSP is architected to be very flexible and provides several implementation options:\n üñ•Ô∏è Server GLSP servers can be written either in Java or with Typescript based on nodejs. üóÇÔ∏è Source Model You can use any format or framework for managing your source model. For the most common choices, GLSP provides dedicated base modules, such as for EMF, emf.cloud, or GModel-JSON, which contains the graphical model directly. üñºÔ∏è Tool Platform Diagram editors can used in multiple tool platforms or used in plain web applications or in an Electron app. While GLSP editors can be integrated into any web application, GLSP provides dedicated integration components for seamlessly deploying a GLSP editor inside of Eclipse Theia, VS Code, or Eclipse RCP.  Due to GLSP\u0026rsquo;s architecture, you can even change any of those options above later on, without impacting other parts of your implementation, or support multiple variants, e.g. VS Code and Eclipse RCP, while sharing almost all of your server and client code.\nTo get you started quickly, GLSP provides project templates for the most popular choices. Thus, please clone the glsp-examples repository and switch to the folder project templates:\ngit clone https://github.com/eclipse-glsp/glsp-examples.git cd glsp-examples/project-templates Now select your preferred server language, source model format, and platform integration (see list below). Switch to the respective folder and follow its readme file.\n üñ•Ô∏è Java ‚óè üóÇÔ∏è EMF ‚óè üñºÔ∏è Theia \u0026ndash; java-emf-theia üñ•Ô∏è Node ‚óè üóÇÔ∏è Custom JSON ‚óè üñºÔ∏è Theia \u0026ndash; node-json-theia üñ•Ô∏è Node ‚óè üóÇÔ∏è Custom JSON ‚óè üñºÔ∏è VS Code \u0026ndash; node-json-vscode  If you don\u0026rsquo;t find your preferred combination, please raise a question in the Github discussions. If you need help on deciding which combination is right for you, please refer to the integrations page or look at our support options.\nWhat next? Once you are up and running based on the project template above, we recommend to start working on the following aspects next:\n ‚û°Ô∏è Add your custom source model instead of using the example model! ‚û°Ô∏è Define the diagram elements to be generated from the source model into the graphical model! ‚û°Ô∏è Make the diagram look the way you want by adjusting the diagram rendering and styling! ‚û°Ô∏è Look at the workflow example to explore the implementation of more advanced editor features  ","permalink":"https://www.eclipse.org/glsp/documentation/gettingstarted/","tags":null,"title":"Getting Started"},{"categories":null,"contents":"As mentioned in the getting started guide, GLSP is architected to be very flexible and provides several options. On this page, we give an overview of the dedicated integration components and point to the respective source code.\n üñ•Ô∏è Server GLSP servers can be written either in Java or with Typescript based on nodejs. üóÇÔ∏è Source Model You can use any format or framework for managing your source model. For the most common choices, GLSP provides dedicated base modules, such as for EMF, emf.cloud, or GModel-JSON, which contains the graphical model directly. üñºÔ∏è Tool Platform Diagram editors can used in multiple tool platforms or used in plain web applications or in an Electron app. GLSP provides dedicated integration components for seamlessly deploying a GLSP editor inside of Eclipse Theia, VS Code, or Eclipse RCP.  Due to GLSP\u0026rsquo;s architecture, you can even change any of those options above later on, without impacting other parts of your implementation, or support multiple variants, e.g. VS Code and Eclipse RCP, while sharing almost all of your server and client code.\nNeed help deciding?  There are many options to choose from. In the following, we list a few hints to help you decide. Please note that especially the tool platform integration doesn\u0026rsquo;t have to be an ultimate decision. Many adopters start deploying for one tool platform, e.g. Eclipse Theia, but add support for VS Code later and offer both options in parallel.\n üñ•Ô∏è Server Whether to use Java or Typescript is a matter of taste. However, there also are objective considerations.\n If you aim at providing a VS Code extension or Theia plugin, shipping a node-based GLSP server is easier, because you don\u0026rsquo;t need to worry whether your users have a JVM installed. They\u0026rsquo;ll have a node runtime already, otherwise they couldn\u0026rsquo;t run VS Code or Theia. If you have more control over your users runtime, e.g. because the editor will run in a container in the cloud anyway, this is less of a concern. Using one language (Typescript) for your GLSP server and client leads to a more homogeneous developer experience than having to work with two languages (Java and Typescript). If you already have an editor implementation in Java, e.g. based on GMF, etc., or an EMF metamodel, building a Java-based server opens lots of opportunities for reusing your existing business logic in the GLSP server. If you want to work with EMF source models directly from your GLSP server, e.g. because you want to benefit from its command stack implementation, change notification support, etc., using Java on the GLSP server is clearly better.  üóÇÔ∏è Source Model The choice of a framework to manage your source model mostly depends on two things:\n Which language do you choose for your GLSP server? This may already remove options, e.g. EMF in a node server, unless you externalize the model management into an own separate component, such as an emf.cloud model server. How do you process those source models later on, e.g. for code generation, interpreting it at runtime, etc. and what in what language those components that process your source model are developed with?  Besides, there are a few more considerations.\n Usually you want to provide undo/redo support. If you use a custom serialization and format, you\u0026rsquo;ll have to implement that yourself. Or are there frameworks available that will do that for you? For Java, EMF is a great choice here. You may want to consider using a database instead of a file. This will externalize much of the model and transaction management for you. However, databases have the disadvantage that they shouldn\u0026rsquo;t be checked into a git repository. So you opt out of a completely file-based approach with that choice. In many use cases, it is advisable to separate the graphical information (such as coordinates) from the \u0026ldquo;semantic\u0026rdquo; information of your model. This way your semantic model will be more concise for later processing. It\u0026rsquo;ll put a slight overhead during editing on top, as you\u0026rsquo;ll need to manage two resources. For EMF, GLSP provides a very simple notation model to capture the graphical information.  More information on the integration components is given in the section on source model integrations.\nüñºÔ∏è Tool Platform The decision for a tool platform has many aspects, such as are you providing a product or a plugin for a generic tool, such as VS Code, are your users already using a certain tool platform, etc.? However, the integration layer of GLSP editors for certain tools is rather thin and it is not much work to provide multiple options here in parallel. So choose what\u0026rsquo;s best for you now, you can easily change or add a tool platform support later.\nMore information on the integration components is given in the section on platform integrations.\n   Package Architecture Depending on your choice of tool platform integration and server framework, a different selection of packages needs to be used. The project templates linked in the getting started guide provide the initial setup of the package architecture for the respective combination of components. However, all of them will have a diagram-specific client package that depends on @glsp/client and a diagram-specific server package that either depends on the node-based GLSP server framework or the Java-based GLSP server framework.\nIrrespectively of the used tool platform integration, server framework or source model integration, your custom glsp-client is always the same and can be reused for all scenarios. Your server implementation is also independent of the respective platform integration and reusable for multiple platforms. Depending on the source model framework, the server may add additional dependencies (e.g. to use the EMF.cloud model server client).\nAs an example, the following figure shows the package architecture for a Theia-based GLSP editor with a node-based server.\n Package overview for node-based server and Theia integration The package your-glsp-client represents your custom client package and your-glsp-server depicts your custom GLSP server package. They contain the diagram-specific implementations for your diagram editor and modeling language.\nPlease note how the your-glsp-client builds upon the @glsp/client and the package your-theia-integration just integrates this as an editor based on @glsp/theia-integration into the Theia tool platform. Your GLSP client and your Theia integration have an indirect dependency to Eclipse Sprotty and its Theia glue code. Both the client and the server share a common package @glsp/protocol that defines the action types.\nServer Frameworks GLSP servers can be written in any language, as they run in a separate process and communicate via JSON-RCP with the client. To make it easier to develop GLSP servers, however, GLSP provides two server frameworks:\n GLSP server framework for Java GLSP server framework for Node  Even though they are built with different runtimes and languages, they are structurally very similar. Both use dependency injection (DI) for hooking up your diagram-specific providers, services, and handlers or for replacing default implementation with customized implementations.\nThe Java-based GLSP server uses Google Guice as a dependency injection framework. With Google Guice, there is one main DI module that contains each binding in a dedicated method. Adopters can extend this module and customize it by overriding dedicated binding methods. The node-based GLSP server uses inversify.js as dependency injection framework.\nFor both servers, GLSP provides dedicated abstract base classes named DiagramModule, which are intended to be extended in order to implement a concrete diagram server. The idea of those abstract base classes is that the abstract methods they contain MUST be implemented in order to show a diagram, e.g. the source model storage and the graphical model factory, and additional methods MAY be overwritten to add functionalities, such as certain editing operations or model validation, or to customize default behavior. There are also pre-configured diagram modules for certain source models, described below, e.g. for EMF or EMF.cloud, which already bind relevant implementations.\nThe remainder of this documentation shows, whenever applicable, a code example for both servers. Also there are project templates for both servers, as listed in the getting started guide, as well as an example server for the common \u0026ldquo;workflow diagram\u0026rdquo;, in each of the server repositories, linked above.\nServer DI Container vs Diagram Session DI Container It is worth noting, that GLSP servers distinguish between two DI containers:\n Server DI Container  The server DI container is used to configure global components and services that are not related to a specific session diagram as well as components that are shared between all session containers. Diagram Session DI Containers  Each client session has a dedicated DI container which holds the session-specific information as well as dedicated instances of handlers, states, etc. Each client session container is associated with a single diagram language and is configured with the corresponding diagram module.  Source Model Integrations GLSP works with any source model format or framework for managing your source model, as the implementation for loading source models and translating them into diagrams needs to be provided by the developer of the diagram editor. However, there are recurring popular choices, for which GLSP provides base modules with default implementations for a specific source model framework.\n Integration for EMF models Integration for EMF models with a separate notation model Integration for EMF.cloud model server Abstract base diagram module for storing and modifying GModels as JSON files directly: Java or node  Platform Integrations GLSP-based editors can be integrated into any web application frame. To ease the platform integration for adopters, however, dedicated glue code frameworks are provided for\n Creating an extension to provide a GLSP editor for Eclipse Theia Creating an extension to provide a GLSP editor for VSCode Creating a plugin to prove a GLSP editor for the Eclipse IDE Creating a standalone GLSP web editor based on plain javascript  In general it is recommended to keep the GLSP diagram implementation separated from the platform integration code by splitting them into separate packages. With that, the core GLSP editor can be easily reused and integrated into another platform.\nAs an example, the GLSP Workflow example provides the GLSP diagram implementation in the @eclipse-glsp/workflow-glsp package. All platform-specific integration examples import this package and provide a small integration package containing the platform-specific glue code on top.\n","permalink":"https://www.eclipse.org/glsp/documentation/integrations/","tags":null,"title":"Servers \u0026 Integrations"},{"categories":null,"contents":"Source Model The source model represents the actual data that is represented in the diagram and that is modified when the user applies changes in the diagram. Typical source model formats are EMF models, JSON files, and databases, etc. However, GLSP and the GLSP server frameworks don\u0026rsquo;t put any restrictions on what the format of this source model is. This is achieved by putting developers of GLSP diagram servers in charge of defining how to load a source model, how to transform it into a graphical model, which is the description of the diagram to be rendered, and how to manipulate the source model, if a user edits a diagram.\nTherefore, a GLSP server needs to provide the following implementations:\n Source model storage, which defines how to load and store source models. Graphical model factory, which defines how the source model is transformed into a graphical model. Edit operation handlers that manipulate the source model, based on user actions performed in the diagram.  Loading Source Models and Showing a Diagram To load a source model and show a diagram, the following steps are performed:\n The client sends a RequestModelAction with a URI or other arguments for identifying a source model to the server The server invokes the source model storage to load the source model identified by the arguments sent by the client The server invokes the graphical model factory to translate the source model into the graphical model The server sends the created graphical model to the client The client renders graphical model  Processing Edit Operations When a user performs an edit operation in the diagram:\n The client sends an operation request to the server The server invokes the registered edit operation handler, which modifies the underlying source model directly The server applies the graphical model factory to the modified source model to create a new graphical model The server sends the created graphical model to the client The client re-renders the diagram according to the new version of the graphical model  As can be seen in the steps above for loading and editing source models, both processes share many steps and are based on the same three custom implementations for particular source models. Thus, by providing these three implementations, any source model format can be supported with GLSP.\nPlease note that GLSP provides generic base implementations for typical source model types.\nSource Model Storage and Model State Every GLSP server needs to provide an implementation of the interface SourceModelStorage. Implementations of this interface are responsible for loading source models from a specific resource, such as an EMF model, a JSON file, or a database, into the GLSP server\u0026rsquo;s model state.\nThe ModelState is the central stateful object within a client session that represents the information about the current state of the original source model. All other services and handlers may access the model state to obtain the required information about the model in order to perform their diagram editing tasks.\nAs you typically need to store custom information that is specific to your model in the model state, you typically also bind a custom implementation that represents your model state. This implementation usually implements the interface GModelState (and extends the base class DefaultGModelState).\nJava GLSP Server protected Class\u0026lt;? extends GModelState\u0026gt; bindGModelState() { return MyModelState.class; }  Node GLSP Server protected override bindModelState(): BindingTarget\u0026lt;ModelState\u0026gt; { return MyModelState; }   Now as we have registered our model state implementation, we can look at the source model loading. First, we need to make the GLSP server aware of your SourceModelStorage implementation, so you have to bind your implementation of the SourceModelStorage interface in the server‚Äôs DI module:\nJava GLSP Server @Override protected Class\u0026lt;? extends SourceModelStorage\u0026gt; bindSourceModelStorage() { return MySourceModelStorage.class; }  Node GLSP Server protected bindSourceModelStorage(): BindingTarget\u0026lt;SourceModelStorage\u0026gt; { return MySourceModelStorage; }   The registered implementation of the source model storage needs to provide two functionalities:\n Loading source models, based on the parameters that are contained in the RequestModelAction, and adding them into the session‚Äôs model state. The implementation mostly depends on where you need to load your source model(s) from and what kind of model(s) you are dealing with (files, XML, JSON, EMF, a database, etc.). Saving the current version of the source model from the GModelState back into its original resource (files, XML, EMF, database, etc.). This method is invoked when the client sends a SaveModelAction.  Java GLSP Server public class MySourceModelStorage implements SourceModelStorage { @Inject protected MyModelState modelState; @Override public void loadSourceModel(final RequestModelAction action) { final String uri = MapUtil.getValue(action.options, \u0026#34;sourceURI\u0026#34;); // load your model from file, EMF, database, etc.  final YourModel model = ‚Ä¶; // add information needed about your model into the model state  modelState.setModel(model); } @Override public void saveSourceModel(final SaveModelAction action) { // get the current version of your model  final YourModel model = modelState.getModel(); // get the information to know where to store your model  final String uri = action.getFileUri().get(); try { // store your model  } catch (IOException e) { LOG.error(e); throw new GLSPServerException(\u0026#34;An error occurred while saving the model.\u0026#34;, e); } } }  Node GLSP Server @injectable() export class MySourceModelStorage implements SourceModelStorage { @inject(MyModelState) protected modelState: MyModelState; loadSourceModel(action: RequestModelAction): MaybePromise\u0026lt;void\u0026gt; { const uri = action.options![\u0026#34;sourceURI\u0026#34;]; // load your model from file, EMF, database, etc.  const model = ‚Ä¶; // add information needed about your model into the model state  this.modelState.model=model; } saveSourceModel(action: SaveModelAction): MaybePromise\u0026lt;void\u0026gt; { // get the current version of your model  const model = this.modelState.model; // get the information to know where to store your model  const uri = this.modelState.sourceUri; try { // store your model  } catch (error) { throw new GLSPServerError(`Could not load model from file: ${this.modelState.sourceUri}`, error); } } }   The GLSP Workflow example is an example, in which in which the source model is a JSON file that contains the GModel directly. In such a scenario, you can use the plain GModelState and the JsonFileGModelStorage.\nOnce the source model has been loaded into the model state, the GLSP server invokes the configured GModelFactory to derive the graphical model from the source model and issues model update for the client.\n ‚û°Ô∏è Let\u0026rsquo;s look at how the source model is translated into a graphical model next!\n","permalink":"https://www.eclipse.org/glsp/documentation/sourcemodel/","tags":null,"title":"Source Model \u0026 State"},{"categories":null,"contents":"The graphical model is a serializable description of the diagram to be visualized on the client. It is the central communication artifact between client and server. The server creates the graphical model from an arbitrary source model by invoking a so-called GModelFactory and sends the graphical model to the client. Thus, the client doesn\u0026rsquo;t need to know from which source model it has been generated and how to manipulate the source model. However, the client interprets the graphical model in order to render a visualization of the diagram described in the graphical model.\nGraphical Model Structure The graphical model is composed of elements and edges. Each element or edge has a unique identifier and a type. The graphical model elements are organized in a tree, as defined by the parent-child relationship between elements, with a single root element. The graphical model library consists of several common base classes, such as nodes, ports, labels, compartments, but can be extended with additional properties or even new types, if needed.\nThe graphical model is typically composed of the following elements.\n GModelRoot: Each graphical model must have exactly one root  GShapeElement: A graphical element is represented by a shape with visual bounds (position and size). Note that such elements can be nested based on their parent-child relationship. There are a the following concrete sub-types of shapes:  GNode: Representation of a logical diagram node GPort: Ports are typically children of nodes and serve as connection points for edges GLabel: Representation of a text label GCompartment: A generic container element used for element grouping   GEdge: A diagram edge that connects a source element and a target element (typically nodes or ports).    SModel: Graphical model on the client The default GLSP client uses Sprotty, an SVG-based diagramming framework, to render diagrams. Sprotty uses a model to represent a diagram too \u0026ndash; the so-called SModel. The graphical model of GLSP is based on the SModel and, thus, can be seen as a compatible extension of the Sprotty model.\nAs a naming convention, GLSP uses the S-prefix for model elements on the client to conform to the naming of the Sprotty model. Thus, a node of the graphical model on the GLSP client is called SNode, whereas it is called GNode on the server, the same is true for SEdge / GEdge, etc. Semantically, those elements, however, are equivalent and are exchanged transparently between the server and the client via JSON-RPC.\nGModel: Graphical model on the server The Java-based GLSP server uses EMF to represent and manage the graphical model internally. Note that this is just an internal way of representing the GModel at runtime but doesn‚Äôt mean that adopters need to represent their original source models with EMF too. The GLSP server uses EMF in order to reuse its model management and editing capabilities, its command stack and command-based editing. Therefore, the graphical model is described as an Ecore model and the corresponding Java classes are automatically generated from this model. Using GSON, the GModel is then serialized and deserialized to JSON before it is sent via JSON-RPC to the client.\nThe node-based GLSP server provides a graph model library, which defines the graph model types, such as GNode, GEdge, etc. alongside a builder API to make creating instances more convenient. However, as the node-based GLSP server and the GLSP client are both based on ES6, this graph library is based on graph model definitions that are used on the client.\nGraphical Model Factory After the initial loading of the source model ‚Äì and also after each change of the source model ‚Äì the GLSP server generates a graphical model from the source model in order to define what is to be rendered on the client.\nThe generation of the graphical model from the original source model is the responsibility of the GModelFactory. Therefore, the GModelFactory obtains the source model from the model state and generates a new graphical model from it. Implementations of the GModelFactory are by nature very specific to the source model and the diagram type. Thus, in almost every GLSP editor project, a custom GModelFactory implementation is provided.\nThe only exception are GLSP editors that directly operate on GModels; that is, the GModel is persisted and loaded directly by the registered implementation of the source model storage. In such cases, no transformation from the source model to the GModel needs to be provided as the source model already is the GModel. Thus, the so-called NullImpl of the GModelFactory can be used. An example for such a use case is provided in the GLSP Workflow example.\nFor all other use cases, an implementation of the GModelFactory needs to be provided and registered in the server DI module as follows.\nJava GLSP Server @Override protected Class\u0026lt;? extends GModelFactory\u0026gt; bindGModelFactory() { return MyModelFactory.class; }  Node GLSP Server protected override bindGModelFactory(): BindingTarget\u0026lt;GModelFactory\u0026gt; { return MyModelFactory; }   For the sake of an example, let‚Äôs assume that the source model is a simple list of named entities. Each entity should be visualized as a node with a label, which indicates its name. Then the corresponding ModelFactory could look as follows.\nJava GLSP Server public class MyModelFactory implements GModelFactory { @Inject protected MyModelState modelState; @Override public void createGModel() { List\u0026lt;Entity\u0026gt; entities = modelState.getModel().getEntities(); List\u0026lt;GModelElement\u0026gt; entityNodes = entities.stream().map(entity -\u0026gt; //  new GNodeBuilder(\u0026#34;node:entity\u0026#34;) .layout(\u0026#34;vbox\u0026#34;) .add(new GLabelBuilder() .text(entity.getName()) .build()) .build()) .collect(Collectors.toList()); GGraph newModel = new GGraphBuilder() .id(\u0026#34;entity-graph\u0026#34;) .addAll(entityNodes) .build(); modelState.updateRoot(newModel); } }  Node GLSP Server @injectable() export class MyModelFactory implements GModelFactory { @inject(MyModelState) protected modelState: MyModelState; createModel(): void { const entities = this.modelState.getModel().getEntities(); const entityNodes = entities.map((entity) =\u0026gt; new GNodeBuilder(GNode) .id(\u0026#34;node:entity\u0026#34;) .layout(\u0026#34;vbox\u0026#34;) .add(new GLabelBuilder(GLabel).text(entity.name).build()) .build() ); const newModel = new GGraphBuilder(GGraph) .id(\u0026#34;entity-graph\u0026#34;) .addChildren(...entityNodes) .build(); this.modelState.updateRoot(newModel); } }   In the createGModel() method the entities are retrieved from the model state, as they have been added there by the source model storage (see Source Model Storage). Then a new GNode is created for each entity. Finally all new nodes are added as children of a newly created GGraph and the graphical root element in the model state is updated.\nNote that we have used the GModelBuilder API in this example to construct new graphical elements. This builder API offers a convenient way to construct new graphical model elements in a concise and fluent fashion. It is the preferred method and should be used over plain constructor creation.\nExtending the Graphical Model GLSP provides a set of default graphical model element classes that can be used to construct the graphical model and already cover a large set of use cases. For advanced use cases the existing base model elements can be customized or additional elements can be introduced. As an example, let‚Äôs have a look at the custom WeightedEdge element introduced by the GLSP Workflow example.\nGLSP Client A WeightedEdge is a special edge that has an optional ‚Äúprobability‚Äù property. We can define such an element by simply subclassing the SEdge class:\nexport class WeightedEdge extends SEdge { probability?: string; } And then the new WeightedEdge type has to be configured in the diagram module (di.config.ts).\nconst workflowDiagramModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... configureModelElement(context, \u0026#39;edge:weighted\u0026#39;, WeightedEdge, WorkflowEdgeView); ... }  Node GLSP Server For the node GLSP server the new WeightedEdge type can be declared similar to the GLSP client by subclassing the GEdge class.\nexport class WeightedEdge extends GEdge { probability?: string; } To use the builder API for WeightedEdge creation we also have to implement a WeightedEdgeBuilder that extends the default GEdgeBuilder.\nexport class WeightedEdgeBuilder\u0026lt; E extends WeightedEdge = WeightedEdge \u0026gt; extends GEdgeBuilder\u0026lt;E\u0026gt; { probability(probability: string): this { this.proxy.probability = probability; return this; } }  Java GLSP Server When using the Java GLSP server, a new Ecore model that extends the default \u0026ldquo;graph.ecore\u0026rdquo; model has to be created to declare new model elements. For more details, please have a look at the \u0026ldquo;workflow-graph.ecore\u0026rdquo; model in the GLSP Workflow example. Once the WeightedEdge is specified in the Ecore model, the corresponding source code has to be generated. Now the GraphExtension API can be used to configure the \u0026ldquo;workflow-graph.ecore\u0026rdquo; for the workflow diagram language. A class that implements the the corresponding interface has to created:\npublic class WFGraphExtension implements GraphExtension { @Override public EPackage getEPackage() { return WfgraphPackage.eINSTANCE; } @Override public EFactory getEFactory() { return WfgraphFactory.eINSTANCE; } } And then configured in the WorkflowDiagramModule:\n@Override protected Class\u0026lt;? extends GraphExtension\u0026gt; bindGraphExtension() { return WFGraphExtension.class; } To use the builder API for WeightedEdge creation we also have to implement a WeightedEdgeBuilder that extends the default AbstractGEdgeBuilder. \nGeneric Args Every graphical model element type has a generic ‚Äúargs‚Äù property, which can be used to store additional properties as key-value pairs. These arguments can be used as a more lightweight alternative to extending the graphical model classes, especially if only simple extensions are needed.\n ‚û°Ô∏è Let\u0026rsquo;s look at how the graphical model is rendered on the client next!\n","permalink":"https://www.eclipse.org/glsp/documentation/gmodel/","tags":null,"title":"Graphical Model"},{"categories":null,"contents":"Rendering The input of the diagram rendering on the client is the GModel that has been generated on the server from the source model (see Graphical Model) and sent to the client via a SetModelAction or UpdateModelAction. The client is then responsible for rendering the GModel.\nIn order to render the received graphical model, each graphical element type needs to be associated with a view on the client. A view defines how a specific type of graphical element shall be transformed into a corresponding SVG representation. The derived SVG elements are then rendered on the canvas of the diagram widget.\nTo define a new view, we have to create a class that implements the IView interface and register it for a specific type that is used in the graphical model. As an example, let‚Äôs configure that the view named SLabelView is used for all elements with the type ‚Äúlabel:custom‚Äù. Therefore, we first need to create a dependency injection module, named customDiagramModule below, and configure the SLabelView for the graphical model element type ‚Äúlabel:custom‚Äù using the configureModelElement() utility function:\nconst customDiagramModule = new ContainerModule( (bind, unbind, isBound, rebind) =\u0026gt; { const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#34;label:custom\u0026#34;, SLabel, SLabelView); } ); The configureModeElement() function takes the inversify binding context, the graphical model type, its model class and its associated view as input. Under the hood this function sets up the necessary bindings so that the GLSP client knows that\n Graphical model elements (received from the GLSP Server) with type ‚Äòlabel:custom‚Äô are deserialized to instances of SLabel Graphical model element with type ‚Äòlabel:custom‚Äô are rendered with the SLabelView  In order to be effective, we need to load the module customDiagramModule defined above in the diagram DI container, aka the root \u0026ldquo;di.config.ts\u0026rdquo; of your diagram implementation. With that, every element of type ‚Äúlabel:custom‚Äù will be rendered with the view implementation SLabelView.\nViews themselves are typically implemented with JSX, which simplifies the definition of SVG elements in Typescript. Therefore, the following generic imports are required in any module declaring a view to enable declaration of svg elements with JSX:\n/** @jsx svg */ import { VNode } from \u0026#34;snabbdom\u0026#34;; import { RenderingContext, svg } from ‚Äò@eclipse-glsp/client‚Äô; In addition, make sure that the following options are set in the tsconfig.json file of your project:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;jsx\u0026#34;:\u0026#34;react\u0026#34;, \u0026#34;reactNamespace\u0026#34;:\u0026#34;JSX\u0026#34; } With that, we can implement a view as follows:\n@injectable() export class SLabelView extends ShapeView { render( label: Readonly\u0026lt;SLabel\u0026gt;, context: RenderingContext ): VNode | undefined { if (!isEdgeLayoutable(label) \u0026amp;\u0026amp; !this.isVisible(label, context)) { return undefined; } const vnode = \u0026lt;text class-sprotty-label={true}\u0026gt;{label.text}\u0026lt;/text\u0026gt;; const subType = getSubType(label); if (subType) { setAttr(vnode, \u0026#34;class\u0026#34;, subType); } return vnode; } } Every view has to implement the render() method. The render() method takes the graphical model element as input and returns the corresponding SVG element as virtual DOM node. The viewer queries all registered views and creates a new virtual DOM which is then used to patch the current DOM of the diagram widget.\nNote that the SLabelView also checks whether the given element is visible and skips the SVG generation if the element is not visible in the diagram canvas. This check is optional but it‚Äôs highly recommended to implement it in your custom views as it heavily improves the rendering performance.\n\nDefault Views The following sections give an overview of available default views in Sprotty and GLSP and how to configure them. All of them are default model elements, which is already configured in the baseViewModule, but for the sake of completeness we list the configuration of the elements in the collapsible example code blocks.\nDefault Sprotty Views The following views are provided by the base framework Sprotty.\nCircularNodeView A CircularNodeView creates a round shape with a radius computed from the shape\u0026rsquo;s size (by default it computes the radius by the minimum of the shape\u0026rsquo;s width or height and divides that by 2). The computation of the radius can be overridden and adapted to custom needs.\nCircular nodes with a radius of `17.5` (1), `42.5` (2) and `7.5`. Example implementation  Java GLSP Server new GNodeBuilder() .type(DefaultTypes.NODE_CIRCLE) .position(point.orElse(GraphUtil.point(0, 0))) .size(GraphUtil.dimension(15, 15)) .build();   Node GLSP Server GNode.builder() .type(DefaultTypes.NODE_CIRCLE) .position(point ?? Point.ORIGIN) .size(15, 15) .build();   The circular node element and its view are configured as follows:\nconfigureModelElement( context, DefaultTypes.NODE_CIRCLE, CircularNode, CircularNodeView );   DiamondNodeView A DiamondNodeView creates a rhombus shape based on the shape\u0026rsquo;s size.\nDiamond nodes with dimensions of `(25,25)` (1), `(20,41)` (2) and `(66,33)`. Example implementation  Java GLSP Server new GNodeBuilder() .type(DefaultTypes.NODE_DIAMOND) .position(point.orElse(GraphUtil.point(0, 0))) .size(GraphUtil.dimension(25, 25)) .build();   Node GLSP Server GNode.builder() .type(DefaultTypes.NODE_DIAMOND) .position(point ?? Point.ORIGIN) .size(25, 25) .build();   The diamond node element and its view are configured as follows:\nconfigureModelElement( context, DefaultTypes.NODE_DIAMOND, DiamondNode, DiamondNodeView );   ExpandButtonView The ExpandButtonView renders a SVG element in the shape of a triangle that allows expandable parent elements to trigger expansion, for example to display further element information.\nA rectangular node with an expandable button that renders additional elements if expanded (right). Example implementation  Java GLSP Server new GNodeBuilder() .type(DefaultTypes.NODE) .addCssClass(\u0026#34;node-expandable\u0026#34;) .position(point.orElse(GraphUtil.point(0, 0))) .size(GraphUtil.dimension(80, 20)) .add(new GCompartmentBuilder() .type(\u0026#34;comp:expandable\u0026#34;) .layout(GConstants.Layout.HBOX) .layoutOptions(new GLayoutOptions().hGap(15)) .add(new GLabelBuilder().text(\u0026#34;Expand\u0026#34;).build()) .add(new GButtonBuilder() .type(DefaultTypes.EXPAND_BUTTON) .addCssClass(\u0026#34;button-expand\u0026#34;) .enabled(true) .build()) .build());   Node GLSP Server GNode.builder() .type(DefaultTypes.NODE) .addCssClass(\u0026#34;node-expandable\u0026#34;) .position(point ?? Point.ORIGIN) .size(80, 20) .add( GCompartment.builder() .type(\u0026#34;comp:expandable\u0026#34;) .layout(\u0026#34;hbox\u0026#34;) .addLayoutOption(\u0026#34;hGap\u0026#34;, 15) .add(GLabel.builder().text(\u0026#34;Expand\u0026#34;).build()) .add( GButton.builder() .type(DefaultTypes.BUTTON_EXPAND) .addCssClass(\u0026#34;button-expand\u0026#34;) .enabled(true) .build() ) .build() ) .build();   The button element and its view are configured as follows:\nconfigureModelElement( context, DefaultTypes.BUTTON_EXPAND, SButton, ExpandButtonView ); To be able to use this view, we need an expandable parent element as well as a corresponding view.\nDefine the compartment element supporting the expandable feature:\nexport class ExpandableCompartment extends SCompartment implements Expandable { static override readonly DEFAULT_FEATURES = [ boundsFeature, layoutContainerFeature, layoutableChildFeature, fadeFeature, expandFeature, ]; expanded = false; } The expandable compartment view renders an additional text element if the element is expanded:\n@injectable() export class ExpandableCompartmentView extends SCompartmentView { override render( compartment: Readonly\u0026lt;ExpandableCompartment\u0026gt;, context: RenderingContext, args?: IViewArgs ): VNode | undefined { const translate = `translate(${compartment.bounds.x}, ${compartment.bounds.y})`; const vnode: VNode = ( \u0026lt;g transform={translate} class-sprotty-comp=\u0026#34;{true}\u0026#34;\u0026gt; {context.renderChildren(compartment)} \u0026lt;/g\u0026gt; ); if (compartment.expanded) { vnode.children?.push( \u0026lt;text x=\u0026#34;50\u0026#34; y=\u0026#34;45\u0026#34;\u0026gt; More information \u0026lt;/text\u0026gt; ); } const subType = getSubType(compartment); if (subType) { setAttr(vnode, \u0026#34;class\u0026#34;, subType); } return vnode; } } Putting those together, we can configure an expandable compartment element and view for the type \u0026quot;comp:expandable\u0026quot;:\nconfigureModelElement( context, \u0026#34;comp:expandable\u0026#34;, ExpandableCompartment, ExpandableCompartmentView ); Finally, to handle the expansion toggle of the button, we register an IActionHandler for the respective sprotty action CollapseExpandAction:\nbind(ExpandHandler).toSelf().inSingletonScope(); configureActionHandler(context, CollapseExpandAction.KIND, ExpandHandler); @injectable() export class ExpandHandler implements IActionHandler { @inject(TYPES.SelectionService) protected selectionService: SelectionService; expansionState: { [key: string]: boolean } = {}; handle(action: Action): void { switch (action.kind) { case CollapseExpandAction.KIND: this.handleCollapseExpandAction(action as CollapseExpandAction); break; } } get modelRoot(): Readonly\u0026lt;SModelRoot\u0026gt; { return this.selectionService.getModelRoot(); } protected handleCollapseExpandAction(action: CollapseExpandAction): void { action.expandIds.forEach((id) =\u0026gt; (this.expansionState[id] = true)); action.collapseIds.forEach((id) =\u0026gt; (this.expansionState[id] = false)); this.applyExpansionState(); } protected applyExpansionState(): void { // eslint-disable-next-line guard-for-in  for (const id in this.expansionState) { const element = this.modelRoot.index.getById(id); if (element \u0026amp;\u0026amp; element instanceof SParentElement \u0026amp;\u0026amp; element.children) { const expanded = this.expansionState[id]; (element as any).expanded = expanded; } } } }   ForeignObjectView The ForeignObjectView renders elements that are foreign to SVG, such as HTML, MathML, etc. as specified in their namespace and code property. Usually such an element is contained by a node view that enables features, such as resizing and moving of the element.\nMulti line text box, using xhtml. Example implementation A common example use case for using a ForeignObjectView is to benefit from word wrapping support of HTML to show multiline text box. Therefore we would create a custom text node (which extends the ForeignObjectElement) which is contained by a parent node (hence we will configure both as node types in the diagram configuration).\n Java GLSP Server String multiLineComment = \u0026#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\n\u0026#34; + \u0026#34;Nam at tellus quis lacus auctor congue vel sit amet lectus.\\n\u0026#34; + \u0026#34;Cras interdum lectus vel enim mollis maximus.\u0026#34;; new GNodeBuilder(\u0026#34;comment-node-parent\u0026#34;) .addCssClass(\u0026#34;comment-node-parent\u0026#34;) .size(GraphUtil.dimension(720, 125)) .position(point.orElse(GraphUtil.point(0, 0))) .add(new GNodeBuilder(\u0026#34;comment-node\u0026#34;) .addArgument(\u0026#34;text\u0026#34;, multiLineComment) .build()) .build();   Node GLSP Server const multiLineComment = \u0026#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\n\u0026#34; + \u0026#34;Nam at tellus quis lacus auctor congue vel sit amet lectus.\\n\u0026#34; + \u0026#34;Cras interdum lectus vel enim mollis maximus.\u0026#34;; GNode.builder() .type(\u0026#34;comment-node-parent\u0026#34;) .addCssClass(\u0026#34;comment-node-parent\u0026#34;) .size(720, 125) .position(point ?? Point.ORIGIN) .add( GNode.builder() .type(\u0026#34;comment-node\u0026#34;) .addArg(\u0026#34;text\u0026#34;, multiLineComment) .build() ) .build();   We create the custom node element as follows:\nexport class MultiLineTextNode extends ForeignObjectElement implements SArgumentable, EditableLabel { readonly isMultiLine = true; readonly args: Args; text = \u0026#34;\u0026#34;; override set bounds(bounds: Bounds) { /* ignore set bounds, always use the parent\u0026#39;s bounds */ } override get bounds(): Bounds { if (isBoundsAware(this.parent)) { return { x: this.position.x, y: this.position.y, width: this.parent.bounds.width, height: this.parent.bounds.height, }; } return Bounds.EMPTY; } // @ts-expect-error Arguments are set in the element  override get code(): string { if (this.text === \u0026#34;\u0026#34;) { const textArg = this.args[\u0026#34;text\u0026#34;]; if (typeof textArg === \u0026#34;string\u0026#34;) { this.text = textArg; } } return `\u0026lt;pre\u0026gt;${this.text}\u0026lt;/pre\u0026gt;`; } override namespace = \u0026#34;http://www.w3.org/1999/xhtml\u0026#34;; get editControlDimension(): Dimension { return { width: this.bounds.width - 4, height: this.bounds.height - 4, }; } } To register this node type, we configure it with ForeignObjectView, disable moveFeature and selectFeature (as this handled by its parent node). To be able to edit this multi-line comment node we need to enable the editLabelFeature:\nconfigureModelElement( context, \u0026#34;comment-node-parent\u0026#34;, SNode, RoundedCornerNodeView ); configureModelElement( context, \u0026#34;comment-node\u0026#34;, MultiLineTextNode, ForeignObjectView, { disable: [moveFeature, selectFeature], enable: [editLabelFeature], } ); To style the parent node, we add this simple CSS :\n.comment-node-parent .sprotty-node { fill: lightgray; } The resulting diagram element is shown above and the corresponding HTML element code looks like this:\n\u0026lt;g transform=\u0026#34;scale(...) translate(...)\u0026#34;\u0026gt; \u0026lt;g id=\u0026#34;workflow-diagram_0_...\u0026#34; transform=\u0026#34;translate(...)\u0026#34; class=\u0026#34;comment-node-parent\u0026#34; \u0026gt; \u0026lt;rect x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; width=\u0026#34;720\u0026#34; height=\u0026#34;125\u0026#34; class=\u0026#34;sprotty-node\u0026#34;\u0026gt;\u0026lt;/rect\u0026gt; \u0026lt;g class=\u0026#34;comment-node\u0026#34; id=\u0026#34;workflow-diagram_0_...\u0026#34;\u0026gt; \u0026lt;foreignObject requiredFeatures=\u0026#34;http://www.w3.org/TR/SVG11/feature#Extensibility\u0026#34; height=\u0026#34;125\u0026#34; width=\u0026#34;720\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34; \u0026gt; \u0026lt;pre\u0026gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam at tellus quis lacus auctor congue vel sit amet lectus. Cras interdum lectus vel enim mollis maximus. \u0026lt;/pre\u0026gt; \u0026lt;/foreignObject\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/g\u0026gt;   PreRenderedView The PreRenderedView visualizes a previously rendered piece of svg code as a separate SVG element. This enables putting SVG code directly in the graphical model, which may be useful for including complex images for certain use cases. However, usually it is recommended to create a dedicated element type and register a dedicated view, which produces custom SVG, as this yields more flexibility to take bounds, etc., into account.\nThe implementation here is rather similar to the ForeignObjectElement, is a sub-class of ShapedPreRenderedElement. Please see ForeignObjectElement\u0026rsquo;s example implementation.\nRectangularNodeView A RectangularNodeView creates a rectangular shape based on the shape element\u0026rsquo;s size.\nRectangular nodes with dimensions of `(25,25)` (1), `(35,15)` (2) and `(5,40)`. Example implementation  Java GLSP Server new GNodeBuilder() .type(DefaultTypes.NODE_RECTANGLE) .position(point.orElse(GraphUtil.point(0, 0))) .size(GraphUtil.dimension(25, 25)) .build();   Node GLSP Server GNode.builder() .type(DefaultTypes.NODE_RECTANGLE) .position(point ?? Point.ORIGIN) .size(25, 25) .build();   The rectangular node element and its view are configured as follows:\nconfigureModelElement( context, DefaultTypes.NODE_RECTANGLE, RectangularNode, RectangularNodeView );   SGraphView The SGraphView renders the base SVG canvas for an SModel and triggers the rendering of its children.\nExample implementation  Java GLSP Server new GGraphBuilder().build();   Node GLSP Server GGraph.builder().build();   The graph element and its view are configured as follows:\nconfigureModelElement(context, DefaultTypes.GRAPH, GLSPGraph, SGraphView);   SLabelView The SLabelView renders a text element that contains the given label text.\nA label view with the text \"Label 1\" added to a rectangular node. Example implementation  Java GLSP Server new GNodeBuilder() .type(DefaultTypes.NODE_RECTANGLE) .position(point.orElse(GraphUtil.point(0, 0))) .size(GraphUtil.dimension(50, 35)) .add(new GLabelBuilder().text(\u0026#34;Label 1\u0026#34;).build()) .build();   Node GLSP Server GNode.builder() .type(DefaultTypes.NODE_RECTANGLE) .position(point ?? Point.ORIGIN) .size(50, 35) .add(GLabel.builder().text(\u0026#34;Label 1\u0026#34;).build()) .build();   The label element and its view are configured as follows:\nconfigureModelElement(context, DefaultTypes.LABEL, SLabel, SLabelView);   SRoutingHandleView A SRoutingHandleView renders a circle shaped element that serves as routing point for routable elements (e.g. Edges). Its position is computed either by a registered EdgeRouterRegistry or the routing arguments of the element.\nA manually added routing point (dark gray), at position `(0,100)`. Example implementation  Java GLSP Server new GEdgeBuilder() .source(source) // source node element  .target(target) // target node element  .addRoutingPoint(GraphUtil.point(0, 100)) .build();   Node GLSP Server GEdge.builder() .source(source) // source node element  .target(target) // target node element  .addRoutingPoint(0, 100) .build();   The routing handle element and its view are configured as follows:\nconfigureModelElement( context, DefaultTypes.ROUTING_POINT, SRoutingHandle, SRoutingHandleView );   Default GLSP Views The following views are provided by the GLSP client framework.\nGEdgeView A GEdgeView renders a line element which is routed by the EdgeRouterRegistry. The view also triggers the rendering of additional elements (such as mouse handles) and edge children (such as edge labels or routing points).\nA GEdge connection two nodes. Example implementation  Java GLSP Server new GEdgeBuilder() .source(source) // source node element  .target(target) // target node element  .build();   Node GLSP Server GEdge.builder() .source(source) // source node element  .target(target) // target node element  .build();   The edge element and its view are configured as follows:\nconfigureModelElement(context, DefaultTypes.EDGE, SEdge, GEdgeView);   GIssueMarkerView A GIssueMarkerView renders an issue marker on top of shapes. This is used to show validation results on elements (see Model Validation). These issue markers are elements in the shape of an information, warning or error icon based on the severity of the issue.\nA GIssue info marker placed at top left corner of a rectangular node. Example implementation  Java GLSP Server new GNodeBuilder() .type(DefaultTypes.NODE_RECTANGLE) .position(point.orElse(GraphUtil.point(0, 0))) .size(GraphUtil.dimension(50, 35)) .add(new GIssueMarkerBuilder() .addIssue(new GIssueBuilder() .severity(GSeverity.INFO) .build()) .position(GraphUtil.point(-8, -8)) .build());   Node GLSP Server GNode.builder() .type(DefaultTypes.NODE_RECTANGLE) .position(point ?? Point.ORIGIN) .size(50, 35) .add( GIssueMarker.builder() .addIssue({ message: \u0026#34;Information message\u0026#34;, severity: \u0026#34;info\u0026#34; }) .position(-8, -8) .build() ) .build();   The issue marker element and its view are configured as follows:\nconfigureModelElement( context, DefaultTypes.ISSUE_MARKER, SIssueMarker, GIssueMarkerView );   RoundedCornerNodeView A RoundedCornerNodeView creates a rectangular shape based shape\u0026rsquo;s size and computes and renders the corners in a rounded way, based on the corner radius argument. By default, the rounded corner radius defaults to 0.\nA rectangular node with corner radius `0` (1), `3` (2) and `15` (3). Example implementation  Java GLSP Server new GNodeBuilder() .type(DefaultTypes.NODE) .position(point.orElse(GraphUtil.point(0, 0))) .size(GraphUtil.dimension(50, 35)) .addArguments(GArguments.cornerRadius(3)) .build();   Node GLSP Server GNode.builder() .type(DefaultTypes.NODE) .position(point ?? Point.ORIGIN) .size(50, 35) .addArgs(ArgsUtil.cornerRadius(3)) .build();   A node element and its rounded corner node view are configured as follows:\nconfigureModelElement(context, DefaultTypes.NODE, SNode, RoundedCornerNodeView);   StructureCompartmentView The StructureCompartmentView allows to contain children if using the freeform Layout. For more details please see the section about freeform Layout.\n Styling The style of the rendered SVG elements is controlled with plain CSS. CSS classes can be declared directly in the corresponding view. The SLabelView, for instance, adds the CSS class ‚Äòsprotty-label‚Äô to the generated SVG text element.\nconst vnode = \u0026lt;text class-sprotty-label={true}\u0026gt;{label.text}\u0026lt;/text\u0026gt;; Graphical model elements also have a ‚ÄòcssClasses‚Äô property which contains a list of CSS classes to be applied, in addition to the classes defined in the view. For instance, the server could send the following graphical model element:\n{ \u0026#34;id\u0026#34;: \u0026#34;myCustomLabel\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;label:custom\u0026#34;, \u0026#34;cssClasses\u0026#34;: [\u0026#34;my-custom-class\u0026#34;] } Keeping our previous model configuration in mind, the corresponding SVG element now has two css classes applied: ‚Äòsprotty-label‚Äô and ‚Äòmy-custom-class‚Äô.\nBased on those CSS classes, we can define CSS rules:\n.sprotty-label { fill: black; font-size: 100%; } .my-custom-class.sprotty-label { fill: red; } This simple style sheet declares that elements with the class ‚Äòsprotty-label‚Äô‚Äô should be rendered in black. If ‚Äúmy-custom-class‚Äô‚Äô is applied as well they are rendered in red. To load this stylesheet it has to be imported somewhere in the project. Typically this is done in the \u0026ldquo;di.config.ts‚Äù file as it‚Äôs the entry point of the diagram DI container.\nimport \u0026#34;../css/diagram.css\u0026#34;; const customDiagramModule= new ContainerModule((bind,unbind, isBound,rebind)=\u0026gt;{ ‚Ä¶ });  ‚û°Ô∏è Now it\u0026rsquo;s best to learn more about client-side layouting next!\n","permalink":"https://www.eclipse.org/glsp/documentation/rendering/","tags":null,"title":"Rendering \u0026 Styling"},{"categories":null,"contents":"We distinguish between micro and macro layout. Usually, the server is responsible for the macro layout, that is the arrangement of the main model elements (i.e. nodes and edges). This layout is defined already in the graphical model by means of coordinates. In turn, the client is responsible for the micro layout, that is the positioning and size computation of elements within a container element such as nodes. The client side (i.e. micro) layout can be configured in the graphical model, but will be applied on the client during the rendering phase. \nLayout Container Graphical elements that support client-side layouting of contained elements offer a layout property which defines the type of layouter that should be used. In addition, the behavior of the layouter can be configured with a set of layout options.\nFor an example let‚Äôs have a look at the following GNode:\n Java GLSP Server new GNodeBuilder() .layout(GConstants.Layout.VBOX) .layoutOptions(new GLayoutOptions() .hAlign(GConstants.HAlign.Center)) .add(new GLabelBuilder() .text(\u0026#34;label1\u0026#34;) .build()) .add(new GLabelBuilder() .text(\u0026#34;label2\u0026#34;) .build()) .build();   Node GLSP Server GNode.builder() .layout(\u0026#34;vbox\u0026#34;) .addLayoutOption(\u0026#34;hAlign\u0026#34;, \u0026#34;center\u0026#34;) .add(GLabel.builder().text(\u0026#34;label1\u0026#34;).build()) .add(GLabel.builder().text(\u0026#34;label2\u0026#34;).build()) .build();   This node contains two label elements that should be layouted vertically (from top to bottom) using the vbox layouter. In addition, we specify options for that layouter by defining that the children should be centered horizontally.\nLayout Options To adapt the chosen Layout (for more details please see below), the default Layout options AbstractLayoutOptions allow to configure:\n resizeContainer: boolean Indicates, if the container is resizable depending on its children (e.g. true for hbox layout) paddingTop: number Sets the height of the padding area on the top of an element to be positioned in pixel. paddingBottom: number Sets the height of the padding area on the bottom of an element to be positioned in pixel. paddingLeft: number Sets the height of the padding area to the left of an element to be positioned in pixel. paddingRight: number Sets the height of the padding area to the right of an element to be positioned in pixel. paddingFactor: number Defines the multiplication factor for an element\u0026rsquo;s size, which is then added as padding space around this element. E.g. For the stack layout 1 does not add additional padding to the element, 2 doubles the padding area around the element by its size. minWidth: number Defines the minimum width of an element to be positioned. minHeight: number Defines the minimum height of an element to be positioned.  Usage Java GLSP Server To use the Layout options on the GLSP Java Server, there are several utility classes for option keys and values, for example:\n Edge label placement GConstants.EdgeSide: LEFT | RIGHT | TOP | BOTTOM | ON Horizontal alignment GConstants.HAlign: LEFT | CENTER | RIGHT  For more details, please see GLayoutOptions and GConstants.\n Usage Node GLSP Server To use the Layout options on the GLSP Node Server, the support via utility classes for option keys and values is currently very limited, e.g. only the EdgeSide type is available. Therefore please use the dedicated string values in the meantime, e.g. \u0026quot;hAlign\u0026quot; \u0026quot;center\u0026quot; and so on.\n  Default GLSP Layouters In general, layouters can be applied to elements that are compartments, in order to layout the containers based on the sizes of their children.\nThere are four built-in layout types that can be used: hbox, vbox, freeform and stack.\nhbox Layout The HBoxLayouterExt layouts children of a container in a horizontal (left to right) direction.\nThis layouter provides additional layout options via HBoxLayoutOptionsExt:\n hGap: number Defines a horizontal gap between elements in the same container in pixel. vAlign: VAlignment = \u0026lsquo;top\u0026rsquo; | \u0026lsquo;center\u0026rsquo; |¬†\u0026lsquo;bottom\u0026rsquo; Defines the vertical alignment of the element to be positioned. hGrab: boolean Indicates whether the remaining horizontal size can be grabbed by its children. vGrab: boolean Indicates whether the remaining vertical size can be grabbed by its children. prefWidth: number | null Defines the preferred width of the container element, which will be assigned, if there is no manually specified width and the sizes of its children aren\u0026rsquo;t requiring a larger width to fit into the container. prefHeight: number | null Defines the preferred height of the container element, which will be assigned, if there is no manually specified height and the sizes of its children aren\u0026rsquo;t requiring a larger height to fit into the container.  According to the layout options, the children of the container are layouted and as concluding step, the final bounds of the container are computed based on the sum of this children bounds.\nhbox Layout Example This example creates a compartment of the default type DefaultTypes.COMPARTMENT using the hbox layout. It adds two children, one icon compartment (with custom type \u0026quot;icon\u0026quot;) and one label. The layout options define a horizontal gap of 15 pixel between the children of the compartment.\n Java GLSP Server new GCompartmentBuilder() .type(DefaultTypes.COMPARTMENT) .layout(GConstants.Layout.HBOX) .layoutOptions(new GLayoutOptions().hGap(15)) .add(new GCompartmentBuilder() .type(\u0026#34;icon\u0026#34;) .build()) .add(new GLabelBuilder() .text(\u0026#34;label\u0026#34;) .build()) .build(); .build();   Node GLSP Server GCompartment.builder() .type(\u0026#34;comp\u0026#34;) .layout(\u0026#34;hbox\u0026#34;) .addLayoutOption(\u0026#34;hGap\u0026#34;, 15) .add(GCompartment.builder().type(\u0026#34;icon\u0026#34;).build()) .add(GLabel.builder().text(\u0026#34;label\u0026#34;).build()) .build();   On the client side, we need to configure (besides the default elements SCompartment and SLabel) a custom Icon element and a IconView like this: configureModelElement(context, 'icon', Icon, IconView). The Icon element definition and the IconView definition are taken from the workflow example.\nThe resulting element with the obvious horizontal gap between the child elements is shown in the following image:\nUsing no `hGap` layout option (left) or `hGap` layout option with 15 pixel (right) \nvbox Layout The VBoxLayouterExt layouts children of a container in a vertical (top to bottom) direction.\nThis layouter provides additional layout options via VBoxLayoutOptionsExt:\n vGap: number Defines a vertical gap between elements in the same container in pixel. hAlign: HAlignment = \u0026lsquo;left\u0026rsquo; | \u0026lsquo;center\u0026rsquo; |¬†\u0026lsquo;right\u0026rsquo; Defines the horizontal alignment of the element to be positioned. hGrab: boolean Indicates whether the remaining horizontal size can be grabbed by its children. vGrab: boolean Indicates whether the remaining vertical size can be grabbed by its children. prefWidth: number | null Defines the preferred width of the container element, which will be assigned, if there is no manually specified width and the sizes of its children aren\u0026rsquo;t requiring a larger width to fit into the container. prefHeight: number | null Defines the preferred height of the container element, which will be assigned, if there is no manually specified height and the sizes of its children aren\u0026rsquo;t requiring a larger height to fit into the container.  According to the layout options, the children of the container are layouted and as concluding step, the final bounds of the container are computed based on the sum of this children bounds.\nvbox Layout Example This example creates a compartment of the default type DefaultTypes.COMPARTMENT using the vbox layout. It adds two children labels, which are positioned vertically from top to bottom and are centered horizontally.\n Java GLSP Server new GCompartmentBuilder() .type(DefaultTypes.COMPARTMENT) .layout(GConstants.Layout.VBOX) .layoutOptions(new GLayoutOptions().hAlign(GConstants.HAlign.CENTER)) .add(new GCompartmentBuilder() .type(\u0026#34;icon\u0026#34;) .build()) .add(new GLabelBuilder() .text(\u0026#34;Label\u0026#34;) .build()) .build(); .build();   Node GLSP Server GCompartment.builder() .type(\u0026#34;comp\u0026#34;) .layout(\u0026#34;vbox\u0026#34;) .addLayoutOption(\u0026#34;hAlign\u0026#34;, \u0026#34;center\u0026#34;) .add(GCompartment.builder().type(\u0026#34;icon\u0026#34;).build()) .add(GLabel.builder().text(\u0026#34;Label\u0026#34;).build()) .build();   On the client side, we use again the Icon element definition and IconView, please see section hbox Layout Example.\nThe resulting element positions its children vertically from top to bottom and aligns each element horizontally, this is shown in the following image:\nCenter children horizontally (left image) or align children to the left (right image) \nfreeform Layout The FreeFormLayouter positions the children of a container according to their explicit, parent-relative x/y coordinates inside the parent container. This layouter uses the default Layout Options and provides suitable default values (e.g. resizeContainer: true).\nAgain here, the children of the container are positioned according to their explicit positions inside the container and as concluding step, the final bounds of the container are computed based on the required bounds of its children.\nfreeform Layout Example This example creates a compartment of the custom type \u0026quot;comp:structure\u0026quot; using the freeform layout. It adds one child node, at the relative position (75, 35) of the parent container. The parent container defines its preferred size of 250 x 125.\n Java GLSP Server GDimension containerPrefSize = GraphUtil.dimension(250 /*width*/, 125 /*height*/); GPoint childPosition = GraphUtil.point(75 /*x*/, 35 /*y*/); Map\u0026lt;String, Object\u0026gt; layoutOptions = new HashMap\u0026lt;\u0026gt;(); layoutOptions.put(H_GRAB, true); layoutOptions.put(V_GRAB, true); layoutOptions.put(GLayoutOptions.KEY_PREF_WIDTH, containerPrefSize.getWidth()); layoutOptions.put(GLayoutOptions.KEY_PREF_HEIGHT, containerPrefSize.getHeight()); new GCompartmentBuilder() .type(\u0026#34;comp:structure\u0026#34;) .layout(GConstants.Layout.FREEFORM) .layoutOptions(layoutOptions) .add( new GNodeBuilder(DefaultTypes.NODE) .position(childPosition) .build() ) .build();   Node GLSP Server const containerPrefSize = { width: 250, height: 125 }; const childPosition = { x: 75, y: 35 }; const layoutOptions = { [\u0026#34;hGrab\u0026#34;]: true, [\u0026#34;vGrab\u0026#34;]: true, [\u0026#34;prefWidth\u0026#34;]: containerPrefSize.width, [\u0026#34;prefHeight\u0026#34;]: containerPrefSize.height, }; GCompartment.builder() .type(\u0026#34;comp:structure\u0026#34;) .layout(\u0026#34;freeform\u0026#34;) .addLayoutOptions(layoutOptions) .add(GNode.builder().type(\u0026#34;node\u0026#34;).position(childPosition).build()) .build();   On the client side, configure the \u0026quot;comp:structure\u0026quot; compartment as configureModelElement(context, 'struct', SCompartment, StructureCompartmentView).\nThe resulting compartment element positions its child at the desired position. The compartment defines its preferred size, which is used if the children do not enlarge the container. If the preferred size is omitted, the container\u0026rsquo;s size depends on its children.\nContainer with preferred size (left image) or without preferred size (right image) \nDefault Sprotty Layouters It is also possible to use default sprotty layouts, like for example the stack Layout as shown below in the example. Here it is necessary to use the sprotty specific Layouter which is available via sprotty\u0026rsquo;s boundsModule, which is also part of the GLSP client container\u0026rsquo;s default modules. However, we recommend using GLSP layouts.\nstack Layout The StackLayouter positions the children by stacking them on top of each other considering the given alignment.\nThis layouter provides additional layout options via StackLayoutOptions:\n vAlign: VAlignment = \u0026lsquo;top\u0026rsquo; | \u0026lsquo;center\u0026rsquo; |¬†\u0026lsquo;bottom\u0026rsquo; Defines the vertical alignment of the element to be positioned. hAlign: HAlignment = \u0026lsquo;left\u0026rsquo; | \u0026lsquo;center\u0026rsquo; |¬†\u0026lsquo;right\u0026rsquo; Defines the horizontal alignment of the element to be positioned.  The children of the container are positioned according to their order and the defined alignment. Based on that, the maximum height and width are computed and are used as bounds for the container.\n`stack` Layout Example This example creates a compartment of the custom type \u0026quot;comp\u0026quot; using the stack layout. It adds two child nodes - a circle a node and a text label - that are stacked on top of each other.\n Java GLSP Server Map\u0026lt;String, Object\u0026gt; layoutOptions = new HashMap\u0026lt;\u0026gt;(); layoutOptions.put(GLayoutOptions.KEY_H_ALIGN, GConstants.HAlign.CENTER); layoutOptions.put(GLayoutOptions.KEY_RESIZE_CONTAINER, false); new GCompartmentBuilder() .type(DefaultTypes.COMPARTMENT) .layout(GConstants.Layout.STACK) .layoutOptions(layoutOptions) .size(GraphUtil.dimension(35, 35)) .add( new GNodeBuilder(\u0026#34;circle\u0026#34;) .size(GraphUtil.dimension(35, 35)) .build() ) .add( new GLabelBuilder() .text(\u0026#34;A\u0026#34;) .addCssClass(\u0026#34;circle-letter\u0026#34;) .build() ) .build();   Node GLSP Server const layoutOptions = { [\u0026#34;hAlign\u0026#34;]: \u0026#34;center\u0026#34;, [\u0026#34;resizeContainer\u0026#34;]: false, }; GCompartment.builder() .type(\u0026#34;comp\u0026#34;) .layout(\u0026#34;struct\u0026#34;) .addLayoutOptions(layoutOptions) .add(GNode.builder().type(\u0026#34;circle\u0026#34;).size(35, 35).build()) .add(GLabel.builder().text(\u0026#34;A\u0026#34;).addCssClass(\u0026#34;circle-letter\u0026#34;).build()) .build();   On the client side, please make sure that sprotty\u0026rsquo;s boundsModule is registered.\nThe \u0026quot;circle\u0026quot; node element has to be configured as configureModelElement(context, 'circle', CircularNode, CircularNodeView).\nTo style the letter label, we add this simple CSS rule as well:\n.circle-letter { fill: lightsteelblue; } The resulting compartment positions its children on top of each other and centers the label horizontally.\nContainer that stacks its children and positions the label to the left (1), in the center (2) and to the right (3)  \nCustom Layouter Additional custom layouters can be contributed by creating a layouter class that extends the AbstractLayouter and optionally provide custom options that extend the AbstractLayoutOptions.\nIn the following example we show a simple custom layouter that extends the VBoxLayouterExt and provides a custom layout option, which increases the widths and heights of all children by a specified value, the default value is 50 pixel.\nGLSP Client export interface MyCustomLayoutOptions extends VBoxLayoutOptionsExt { enlargeSizeBy: number; } @injectable() export class MyCustomLayouter extends VBoxLayouterExt { static override KIND = \u0026#34;myCustomLayout\u0026#34;; protected override getChildrenSize( container: SParentElement \u0026amp; LayoutContainer, containerOptions: MyCustomLayoutOptions, layouter: StatefulLayouter ): Dimension { const result = super.getChildrenSize(container, containerOptions, layouter); return { width: result.width + containerOptions.enlargeSizeBy, height: result.height + containerOptions.enlargeSizeBy, }; } protected override getDefaultLayoutOptions(): MyCustomLayoutOptions { return { enlargeSizeBy: 50, ...super.getDefaultLayoutOptions(), }; } protected override spread( a: MyCustomLayoutOptions, b: MyCustomLayoutOptions ): MyCustomLayoutOptions { return { ...a, ...b }; } }  Then the new custom layout needs to bound in the diagram module (di.config.ts):\nGLSP Client const myDiagramModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { rebind(VBoxLayouter).to(MyCustomLayouter); }  Custom layouter, which don\u0026rsquo;t overwrite existing ones, should extend the AbstractLayout and can be registered for a certain layouter key, e.g. MyCustomLayouter.KIND, that is used in the layout property of compartments as follows:\nGLSP Client const myDiagramModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { configureLayout({ bind, isBound }, MyCustomLayouter.KIND, MyCustomLayouter); }  With that, the custom layouter is ready to be used by compartments in the graphical model:\n Java GLSP Server new GCompartmentBuilder() .type(DefaultTypes.COMPARTMENT) .layout(\u0026#34;myCustomLayout\u0026#34;) .layoutOptions(Map.of(\u0026#34;enlargeSizeBy\u0026#34;, 15)) .add(new GLabelBuilder() .text(\u0026#34;label\u0026#34;) .build()) .build(); .build();   Node GLSP Server GCompartment.builder() .builder() .layout(\u0026#34;myCustomLayout\u0026#34;) .addLayoutOption(\u0026#34;enlargeSizeBy\u0026#34;, 15) .add(GLabel.builder().text(\u0026#34;label\u0026#34;).build()) .build();    Edge Layout Graphical elements that are typically rendered in combination with an edge such as labels have an edgeLayout property. This can be used to describe how the element should be aligned with the edge.\nFor example let\u0026rsquo;s have a look at the following GLabel:\n Java GLSP Server new GLabelBuilder() .edgePlacement(new GEdgePlacementBuilder() .side(GConstants.EdgeSide.TOP) .position(0.5) .build()) .add(new GLabelBuilder().text(\u0026#34;MyLabel\u0026#34;).build()) .build();   Node GLSP Server GLabel.builder() .edgePlacement({ side: \u0026#34;top\u0026#34;, position: 0.5, rotate: false, offset: 0 }) .add(new GLabelBuilder(GLabel).text(\u0026#34;MyLabel\u0026#34;).build()) .build();   The label above specifies the property edgePlacement. If this label is added as a child of an edge, it will be placed above the edge. The position is defined with 0.5 (i.e. 50 percent of the edge length) which means the label should be placed in the center of the edge. After the edge routes have been rendered the client will query all active edge placements and adjust the label position accordingly.\n","permalink":"https://www.eclipse.org/glsp/documentation/clientlayouting/","tags":null,"title":"Client-side Layouting"},{"categories":null,"contents":"A UI Extension is a concept provided by the underlying framework Sprotty, which allows to display additional UI HTML elements on top of a diagram.\nIt is often used to add UI controls to the diagram. It is also frequently used in the core GLSP functionality:\n the GLSP tool palette the Sprotty command palette the Sprotty EditLabelUI  Register and activate custom UI Extensions To implement a custom UI extension, it is necessary to extend the base AbstractUIExtension. This super class provides a base HTML element (containerElement) which is then the base for the custom UI elements. It also provides utility methods for showing/hiding or handling focus of the extension. To add the actual UI elements to the DOM, the abstract method initializeContents must be implemented.\nThe UIExtensionRegistry allows to register multiple UIExtensions per diagram.\nTo enable a UI Extension a SetUIExtensionVisibilityAction or SetUIExtensionVisibilityCommand with the respective UI Extension ID needs to be invoked.\nAs already mentioned, there is a broad use case for UI extensions, hence also their trigger events can of course vary. UI extensions can be enabled practically with any event that can dispatch an action, e.g. via context menu entries, mouse click events, keyboard events or changes of the diagram itself, for example the change of the diagram\u0026rsquo;s EditMode.\nFor example:\n The GLSP ToolPalette is opened via the GLSP Action EnableToolPalette right after the model was requested in GLSPDiagramWidget#dispatchInitialActions(). The CommandPalette is opened via the keyboard shortcut Ctrl+Space. The EditLabelUI is opened via a double click on an editable Label (e.g. a Category or Task node in the Workflow example). The TaskEditor in the Workflow example is opened via a context menu entry (Direct Edit Task) for the Task node.  The following GIF shows the different triggers of the the mentioned extensions:\nButton Overlay Showcase The following section gives an overview of the necessary bits to create a very simple UI Extension that provides two buttons to center a diagram or fit it to the screen. This showcase is implemented on top of the Workflow example in the glsp-client and glsp-theia-integration.\nAt first, the UI extension needs to be defined, in this case we want the provided base HTML element (containerElement) to contain our buttons. Those buttons should show an icon as well as a descriptive text label and should trigger the respective GLSP Action on click of either one of them. Therefore we create for each button a \u0026lt;div\u0026gt; which contains the icon \u0026lt;i\u0026gt; and the description as adjacent text.\n@injectable() export class ButtonOverlay extends AbstractUIExtension { @inject(TYPES.IActionDispatcher) protected readonly actionDispatcher: IActionDispatcher; static readonly ID = \u0026#34;button-overlay\u0026#34;; id() { return ButtonOverlay.ID; } containerClass() { return ButtonOverlay.ID; } protected initializeContents(containerElement: HTMLElement): void { containerElement.appendChild( this.createButton( \u0026#34;btn_center_diagram\u0026#34;, \u0026#34;Center\u0026#34;, \u0026#34;screen-normal\u0026#34;, CenterAction.create([]) ) ); containerElement.appendChild( this.createButton( \u0026#34;btn_fit_diagram\u0026#34;, \u0026#34;Fit to screen\u0026#34;, \u0026#34;screen-full\u0026#34;, FitToScreenAction.create([]) ) ); } protected createButton( id: string, label: string, codiconId: string, action: Action ): HTMLElement { const baseDiv = document.getElementById(this.options.baseDiv); if (baseDiv) { const button = document.createElement(\u0026#34;div\u0026#34;); const insertedDiv = baseDiv.insertBefore(button, baseDiv.firstChild); button.id = id; button.classList.add(\u0026#34;overlay-button\u0026#34;); const icon = this.createIcon(codiconId); insertedDiv.appendChild(icon); insertedDiv.onclick = () =\u0026gt; this.actionDispatcher.dispatch(action); insertedDiv.insertAdjacentText(\u0026#34;beforeend\u0026#34;, label); return button; } return document.createElement(\u0026#34;div\u0026#34;); } protected createIcon(codiconId: string): HTMLElement { const icon = document.createElement(\u0026#34;i\u0026#34;); icon.classList.add(...codiconCSSClasses(codiconId), \u0026#34;overlay-icon\u0026#34;); return icon; } } To improve the styling of the extension, we make use of the defined CSS classes and position the overlay on the top left of the diagram and reduce the opacity of the buttons by default. On hover, the buttons are fully visible.\n.button-overlay { position: absolute; left: 25px; top: 25px; text-align: left; min-width: 150px; display: flex; flex-direction: column; z-index: 1000; font-family: sans-serif; } .overlay-button { opacity: 0.5; display: flex; } .overlay-button:hover { opacity: 1; cursor: pointer; } .overlay-icon { margin-right: 10px; padding-left: 5px; width: 16px; height: 16px; text-align: center; } To register the extension, it has to be bound as singleton and\nbind(ButtonOverlay).toSelf().inSingletonScope(); bind(TYPES.IUIExtension).toService(ButtonOverlay); To activate our UI extension, for example, alongside the initial actions, we can dispatch the SetUIExtensionVisibilityAction in GLSPDiagramWidget#dispatchInitialActions() after a certain delay.\nprotected dispatchInitialActions(): void { ... setTimeout(() =\u0026gt; { this.actionDispatcher.dispatch(SetUIExtensionVisibilityAction.create({ extensionId: \u0026#34;button-overlay\u0026#34;, visible: true })); }, 50); } The outcome of this showcase is the following subtle UI overlay that offers to center the diagram or fit it to the screen:\n","permalink":"https://www.eclipse.org/glsp/documentation/ui-extensions/","tags":null,"title":"UI Extensions"},{"categories":null,"contents":"Overview The client and the server communicate bidirectionally by sending actions via JSON-RPC. In addition, they are also used for the internal event flow in both the GLSP server and the GLSP client. Any service, mouse tool, etc. can issue actions by invoking the action dispatcher, either on the client or the server.\nThe action dispatcher ‚Äì there is one on the client and one on the server ‚Äì is the central component responsible for dispatching actions to their designated action handlers.\nWhen the dispatcher receives a new action for dispatching, it determines whether it should be dispatched to the internal action handlers only or submitted to the opposite component via JSON-RCP (server or client), based on the registered handlers on the server or the client.\nThe dispatcher distinguishes between notifications and request-response action pairs. Notification actions are one-way actions transferred between client and server. This means when the action dispatcher dispatches a notification it does not wait for a response and directly continues with dispatching the next incoming action. Request actions are typically issued by the GLSP client and can be used to block client-side action dispatching until the server has sent a corresponding response action.\nGLSP defines the standard action types of the graphical language server protocol. However, adopters can add new custom action types. Besides, adopters can replace and extend existing, or add additional action handlers for standard or custom action types.\nTo do that the following steps have to be performed:\n Create a new action specification by providing a corresponding Action implementation Create a new action handler for the newly created action type by providing a implementation of the ActionHandler interface Configure the new action type and handler in the DI module.  Action specification Adopters can declare new custom actions by providing an implementation for the Action interface (resp. base class).\nJava GLSP Server public class MyCustomAction extends Action { public static final String KIND= \u0026#34;myCustomKind\u0026#34;; private String additionalInformation; public MyCustomAction() { super(KIND); } public String getAdditionalInformation() { return additionalInformation; } public void setAdditionalInformation(final String additionalInformation) { this.additionalInformation = additionalInformation; } }  GLSP Client/Node GLSP Server export class MyCustomAction implements Action { static readonly KIND = \u0026#34;myCustomKind\u0026#34;; kind = MyCustomAction.KIND; constructor(public readonly additionalInformation: string) {} }   Each action specification has a unique ‚Äúkind‚Äù and can optionally declare additional data properties. We recommend defining the action kind as a static constant of the implementing class so that it can be accessed from other places, e.g. when registering the handler. Note that action instances need to be serializable to JSON. Therefore the class should only contain plain data properties and no additional business logic. In addition, references to graphical model elements should be done by id.\nIf an action is interchanged between client and server both need to provide the corresponding action definition.\nRequest-Response Actions If the client should be able to dispatch the new action as a blocking request, the action specification class has to implement or extend RequestAction.\nJava GLSP Server public class MyCustomRequestAction extends RequestAction\u0026lt;MyCustomResponseAction\u0026gt; { public static final String KIND= \u0026#34;myCustomRequest\u0026#34;; private String additionalInformation; public MyCustomRequestAction() { super(\u0026#34;my.custom.kind\u0026#34;); } public String getAdditionalInformation() { return additionalInformation; } public void setAdditionalInformation(final String additionalInformation) { this.additionalInformation = additionalInformation; } }  GLSP Client/Node GLSP Server export class MyCustomRequestAction implements RequestAction\u0026lt;MyCustomResponseAction\u0026gt; { static readonly KIND = \u0026#34;myCustomRequest\u0026#34;; kind = MyCustomRequestAction.KIND; constructor( public readonly additionalInformation: string, public readonly requestId = \u0026#34;\u0026#34; ) {} }   Each request action has a ‚ÄúrequestId‚Äù and defines its response action as a type parameter. Of course, the response action specification has to be specified as well:\nJava GLSP Server public class MyCustomResponseAction extends ResponseAction { public static final String KIND = \u0026#34;myCustomResponse\u0026#34;; public MyCustomResponseAction() { super(KIND); } }  GLSP Client/Node GLSP Server export class MyCustomResponseAction implements ResponseAction { static readonly KIND = \u0026#34;myCustomResponse\u0026#34;; kind = MyCustomResponseAction.KIND; constructor(public responseId = \u0026#34;\u0026#34;) {} }   The client can dispatch a request action either in blocking fashion awaiting the response:\n@inject(TYPES.IActionDispatcher) protected actionDispatcher: GLSPActionDispatcher; ‚Ä¶ const response = await this.actionDispatcher.request(new MyCustomRequestAction(‚Äúinfo‚Äù)); // response is of type MyCustomResponseAction or simply dispatch the action as non-blocking notification:\n@inject(TYPES.IActionDispatcher) protected actionDispatcher: GLSPActionDispatcher; ‚Ä¶ this.actionDispatcher.dispatch(new MyCustomRequestAction(‚Äúinfo‚Äù)); Response actions don‚Äôt necessarily have to be part of a response-request action pair and can also be dispatched without a preceding request action. \nImplementing an Action Handler (GLSP Server) To create a new action handler, a class that implements the ActionHandler interface has to be created. In general, an action handler can handle one or more action kinds. However, handling multiple action kinds is typically reserved for rather uncommon edge cases. Therefore, the Java GLSP server provides an abstract base class that is designed for the single-action-kind-per-handler use case.\nJava GLSP Server public class MyCustomActionHandler extends AbstractActionHandler\u0026lt;MyCustomResponseAction\u0026gt; { @Override protected List\u0026lt;Action\u0026gt; executeAction(final MyCustomResponseAction actualAction) { // implement your custom logic to handle the action  // Finally issue response actions  // If no response actions should be issued \u0026#39;none()\u0026#39; can be used;  return listOf(new MyCustomResponseAction()); } }  Node GLSP Server @injectable() export class MyCustomActionHandler implements ActionHandler { actionKinds = [MyCustomRequestAction.KIND]; execute(action: MyCustomRequestAction): MaybePromise\u0026lt;Action[]\u0026gt; { // implement your custom logic to handle the action  // Finally issue response actions  // If no response actions should be issued \u0026#39;[]\u0026#39; can be used;  return [new MyCustomResponseAction()]; } }   The executeAction() method has to be implemented to provide the custom logic of your action handler. It returns a set of response actions that should be dispatched after the handler execution.\nNext, the custom handler has to be configured in the DiagramModule:\nJava GLSP Server @Override protected void configureActionHandlers(final MultiBinding\u0026lt;ActionHandler\u0026gt; binding) { super.configureActionHandlers(binding); binding.add(MyCustomActionHandler.class); }  Node GLSP Server protected override configureActionHandlers(binding: InstanceMultiBinding\u0026lt;ActionHandlerConstructor\u0026gt;): void { super.configureActionHandlers(binding); binding.add(MyCustomActionHandler); }   In addition, each response action of the handler that should be handled by the GLSP client has to be configured as dedicated client action to indicate that it needs to be dispatched to the client:\nJava GLSP Server protected void configureClientActions(final MultiBinding\u0026lt;Action\u0026gt; binding) { super.configureClientAction(binding); binding.add(MyCustomRequestAction.class); }  Node GLSP Server protected configureClientActions( binding: InstanceMultiBinding\u0026lt;string\u0026gt; ): void { super.configureClientActions(binding); binding.add(MyCustomRequestAction.KIND); }   Request-Response Handling Action handlers can treat request-response actions in the same way as plain actions. No special handling is required. The action dispatcher tracks all incoming request actions and automatically intercepts the corresponding response action to set the correct response id. \nImplementing an Action Handler (GLSP Client) On the client, GLSP reuses the IActionHandler API of Sprotty. Therefore, to create a new action handler, a class that implements the IActionHandler interface has to be created.\n@injectable() export class MyCustomResponseActionHandler implements IActionHandler { handle(action: MyCustomResponseAction): void | Action { // implement your custom logic to handle the action  // Optionally issue a response action  } } The handle() method has to be implemented to provide the custom logic of your action handler. It optionally returns a response action that should be dispatched after the handler execution.\nA dedicated configuration function is available to configure the new action handler in the diagram module (‚Äúdi.config.ts‚Äù):\nconst diagramModule = new ContainerModule((bind, _unbind, isBound, rebind) =\u0026gt; { const context = { bind, _unbind, isBound, rebind }; configureActionHandler(context, MyCustomResponseAction.KIND, MyCustomResponseActionHandler); } The configureActionHandler() function takes the inversify binding context, the action kind that should be handled, and the action handler class, as input. It registers the action handler for the given action kind, so that it can be retrieved by the action dispatcher.\nNote that we don‚Äôt have to explicitly declare which actions are handled by the GLSP Server. The GLSP server sends this information during the initialization process and the GLSP client automatically sets up the necessary action (handler) registrations.\n","permalink":"https://www.eclipse.org/glsp/documentation/actionhandler/","tags":null,"title":"Actions \u0026 Action Handler"},{"categories":null,"contents":"This section is currently work in progress. Please come back later.\n","permalink":"https://www.eclipse.org/glsp/documentation/modeloperations/","tags":null,"title":"Model Operations"},{"categories":null,"contents":"Validation rules for the source and/or graphical model are typically implemented on the GLSP server, as only the server has the full knowledge of the underlying model. Model validation rules are by nature specific to the underlying modeling language and therefore have to be provided by the specific server implementation. The interface to be implemented is called ModelValidator. The ModelValidator is invoked for a set of model elements and creates issue markers for them.\nIn many scenarios, the ModelValidator implementation delegates to another component, such as EMF validation, etc.\nLet\u0026rsquo;s have a look at a simple example implementation of a model validator:\nJava Server public class CustomModelValidator implements ModelValidator { @Override public List\u0026lt;Marker\u0026gt; validate(final GModelElement... elements) { List\u0026lt;Marker\u0026gt; markers = new ArrayList\u0026lt;\u0026gt;(); for (GModelElement element : elements) { if (element instanceof GNode) { markers.add(validateGNode((GNode) element)); } element.getChildren().forEach(child -\u0026gt; markers.addAll(validate(child))); } return markers; } protected Marker validateGNode(final GNode element) { return new Marker(\u0026#34;Node\u0026#34;, \u0026#34;This graphical element is a node\u0026#34;, element.getId(), MarkerKind.INFO); } }  Node Server @injectable() export class CustomModelValidator implements ModelValidator { @inject(GModelState) protected readonly modelState: GModelState; validate(elements: GModelElement[]): Marker[] { const markers: Marker[] = []; for (const element of elements) { if (element instanceof GNode) { markers.push(this.validateGNode(element)); } if (element.children) { markers.push(...this.validate(element.children)); } } return markers; } protected validateGNode(element: GNode): Marker { return { kind: MarkerKind.INFO, description: \u0026#39;This graphical element is a node\u0026#39;, elementId: element.id, label: \u0026#39;Node\u0026#39; }; } }   This validator iterates over the given model elements and their children and creates a new info marker for each element that is an instance of GNode. An issue marker is associated with a graphical element via its ‚Äúid‚Äù. In addition, the marker has a label, an issue description and a kind indicating its severity. The severity can either be ‚ÄúINFO‚Äù,‚ÄùWARN‚Äù or ‚ÄúERROR‚Äù. The created markers are then propagated to the client via a SetMarkersAction.\nTo enable the custom model validator, it has to be bound in the diagram module.\nJava Server @Override protected Class\u0026lt;? extends ModelValidator\u0026gt; bindModelValidator() { return CustomModelValidator.class; }  Node Server protected override bindModelValidator(): BindingTarget\u0026lt;ModelValidator\u0026gt; | undefined { return CustomModelValidator; }   Validation is typically triggered by the client via a RequestMarkersAction ‚Äì e.g., by clicking the validation button in the tool palette. In addition, the server can also send a SetMarkersAction to the client without a preceding request at any time. This is useful to implement features such as automatic live validation after each model update.\nThe client visualizes each marker by decorating the corresponding graphical element with an icon indicating the severity. When hovering over the issue marker a tooltip with the issue description is displayed.\nDepending on the chosen platform integration, validation markers are propagated to other user interface components. For instance, when integrating GLSP into Theia, markers are also translated into items shown in the Problems view.\n","permalink":"https://www.eclipse.org/glsp/documentation/validation/","tags":null,"title":"Model Validation"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/search/","tags":null,"title":"Search"},{"categories":null,"contents":"Articles  Eclipse GLSP 1.0 Release is here! Eclipse GLSP 1.0: Leading-edge diagram editor support Eclipse GLSP 1.0: TypeScript support for GLSP server implementations Web-based diagram editor features in Eclipse GLSP GLSP: Diagrams in VS Code, Theia, Eclipse and plain HTML Diagram editors in Theia and VS Code with Eclipse GLSP A diagram editor framework for VS Code A hands-on tutorial for Eclipse GLSP A minimal diagram editor example for Eclipse GLSP Building diagram editors in Eclipse Theia with GLSP The workflow diagram example for Eclipse GLSP A web-based modeling tool based on Eclipse Theia and GLSP An introduction to the Graphical Language Server Protocol/Platform (Eclipse GLSP)  Videos  Cloud IDE Days 2022: Diagram Editors in Cloud IDEs EclipseCon 2021: Diagram editors with Eclipse GLSP - 1.0 Cloud Tool Time: Diagram editors in Theia and VSCode with Eclipse GLSP EclipseCon 2020: Diagram editors in the web with Eclipse GLSP EclipseCon 2020: Ecore tools in the cloud - behind the scenes EclipseCon 2020: Web-based modeling tools with EMF.cloud and GLSP Eclipse Virtual Meet Up 2019: Diagrams in web and space with GLSP EclipseCon 2019: Diagrams in web and space with GLSP EclipseCon Europe 2018: Towards a Graphical Language Server Protocol for Diagrams?  ","permalink":"https://www.eclipse.org/glsp/documentation/additionals/","tags":null,"title":"More Articles \u0026 Videos"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/categories/","tags":null,"title":"Categories"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/documentation/","tags":null,"title":"Documentation"},{"categories":null,"contents":"An example GLSP diagram including one GLSP server and several diagram client integrations (VS Code, Eclipse Theia, plain HTML and Eclipse desktop IDE). The example can be used to try out the GLSP features in a running version. Most components of GLSP, such as the GLSP server framework or the Theia integration implement the workflow diagram as a consistent example. As the example is fully open source, you can use the example as a blueprint for a custom implementation of a GLSP diagram. The example diagram is a simplified flow chart with different types of nodes and edges (see screen shot below)  To launch/browse the example, please use the links below leading to the components of the workflow diagram example. You will need the workflow GLSP server (there is only one) and at least one client integration (select the one you are interested in). Launch the server first and then the client of your choice to try the example. Alternatively, you can try the workflow example online embedded into an example tool (see last option below) ","permalink":"https://www.eclipse.org/glsp/examples/","tags":null,"title":"Examples"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/gallery/","tags":null,"title":"Gallery"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/","tags":null,"title":"GLSP"},{"categories":null,"contents":"Support for GLSP and for projects adopting GLSP is provided by ","permalink":"https://www.eclipse.org/glsp/support/","tags":null,"title":"Support"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/tags/","tags":null,"title":"Tags"}]