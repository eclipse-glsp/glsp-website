[{"categories":null,"contents":"The Graphical Language Server Platform (GLSP) is a client-server framework for building web-based diagram editors. It follows an architectural pattern similar to the hugely popular Language Server Protocol, but applies it to graphical modeling and diagram editors. With that, GLSP enables the development of modern, web-based diagram editors, whereas the heavy lifting, such as loading, interpreting, and editing diagrams according to the rules of the graphical diagram language, is encapsulated in the server. Consequently, diagram editors can easily be integrated with multiple tool platforms, such as VS Code, Eclipse Theia, Eclipse RCP, and in standalone or web apps.\nA GLSP Server is a separate backend process and provides the language-specific smarts and editing capabilities. It communicates with a GLSP Client over JSON-RPC with an extensible action protocol. Each application has one GLSP client. A GLSP client can have multiple sessions, whereas each session represents a single diagram editor instance. Each client is handled by exactly one GLSP server. A server can handle multiple clients, each within a dedicated client session.\nHow it works The GLSP server is responsible for loading an arbitrary source model, e.g. a JSON file, EMF model, or database, and defines how to transform it into the graphical model. The graphical model is a serializable description of the diagram to be rendered on the client. It is the central communication artifact that is transferred to the client.\nThe GLSP client receives the graphical model as input and renders it. Additionally, the client requests information on editing operations that can be applied in the context of the graphical model. Based on this information, the client can provide the editing tools for making changes to the diagram, such as moving elements, adding nodes or edges, changing labels, etc.\nOnce a user performs a change in the diagram, the client sends a notification to the server. The server then applies the operation back to the source model, regenerates the graphical model and updates the client with the new version of the graphical model. The client will then update the rendered diagram based on the new graphical model it received.\nCustomization and Extension As diagram editors are by nature very specific to the respective diagram language, GLSP is designed with a strong focus on customizability and extensibility. To this end, GLSP applies two principles:\n Dependency Injection Both the client and the server are using an inversion of control pattern based on dependency injection (DI) with inversify.js and Guice. Every service and component is configured in a global DI container and can simply be extended or even replaced with a custom implementation. Adopters consequently have the same power for their diagram editors, as the framework authors. Slim abstractions and direct access to the underlying technologies Especially, when it comes to the look \u0026amp; feel of a diagram editor, it is crucial to have full control over the rendering and the UI. Therefore, GLSP gives full access and control over the underlying UI technologies, such as Eclipse Sprotty, SVG and CSS, editing tools, user interface controls (HTML), without abstraction layers where control matters. Avoiding abstraction layers also enables an excellent debugging experience.  ‚û°Ô∏è Now it is time to get started!\n","permalink":"https://www.eclipse.org/glsp/documentation/overview/","tags":null,"title":"Overview"},{"categories":null,"contents":"GLSP is architected to be very flexible and provides several implementation options:\n üñ•Ô∏è Server GLSP servers can be written either in Java or with Typescript based on nodejs. üóÇÔ∏è Source Model You can use any format or framework for managing your source model. For the most common choices, GLSP provides dedicated base modules, such as for EMF, emf.cloud, or GModel-JSON, which contains the graphical model directly. üñºÔ∏è Tool Platform Diagram editors can used in multiple tool platforms or used in plain web applications or in an Electron app. While GLSP editors can be integrated into any web application, GLSP provides dedicated integration components for seamlessly deploying a GLSP editor inside of Eclipse Theia, VS Code, or Eclipse RCP.  Due to GLSP\u0026rsquo;s architecture, you can even change any of those options above later on, without impacting other parts of your implementation, or support multiple variants, e.g. VS Code and Eclipse RCP, while sharing almost all of your server and client code.\nTo get you started quickly, GLSP provides project templates for the most popular choices. Thus, please clone the glsp-examples repository and switch to the folder project templates:\ngit clone https://github.com/eclipse-glsp/glsp-examples.git cd glsp-examples/project-templates Now select your preferred server language, source model format, and platform integration (see list below). Switch to the respective folder and follow its readme file.\n üñ•Ô∏è Java ‚óè üóÇÔ∏è EMF ‚óè üñºÔ∏è Theia \u0026ndash; java-emf-theia üñ•Ô∏è Node ‚óè üóÇÔ∏è Custom JSON ‚óè üñºÔ∏è Theia \u0026ndash; node-json-theia (coming soon) üñ•Ô∏è Node ‚óè üóÇÔ∏è Custom JSON ‚óè üñºÔ∏è VS Code \u0026ndash; node-json-vscode  If you don\u0026rsquo;t find your preferred combination, please raise a question in the Github discussions. If you need help on deciding which combination is right for you, please refer to the integrations page or look at our support options.\nWhat next? Once you are up and running based on the project template above, we recommend to start working on the following aspects next:\n ‚û°Ô∏è Add your custom source model instead of using the example model! ‚û°Ô∏è Define the diagram elements to be generated from the source model into the graphical model! ‚û°Ô∏è Make the diagram look the way you want by adjusting the diagram rendering and styling! ‚û°Ô∏è Look at the workflow example to explore the implementation of more advanced editor features  ","permalink":"https://www.eclipse.org/glsp/documentation/gettingstarted/","tags":null,"title":"Getting Started"},{"categories":null,"contents":"As mentioned in the getting started guide, GLSP is architected to be very flexible and provides several options. On this page, we give an overview of the dedicated integration components and point to the respective source code.\n üñ•Ô∏è Server GLSP servers can be written either in Java or with Typescript based on nodejs. üóÇÔ∏è Source Model You can use any format or framework for managing your source model. For the most common choices, GLSP provides dedicated base modules, such as for EMF, emf.cloud, or GModel-JSON, which contains the graphical model directly. üñºÔ∏è Tool Platform Diagram editors can used in multiple tool platforms or used in plain web applications or in an Electron app. GLSP provides dedicated integration components for seamlessly deploying a GLSP editor inside of Eclipse Theia, VS Code, or Eclipse RCP.  Due to GLSP\u0026rsquo;s architecture, you can even change any of those options above later on, without impacting other parts of your implementation, or support multiple variants, e.g. VS Code and Eclipse RCP, while sharing almost all of your server and client code.\nNeed help deciding?  There are many options to choose from. In the following, we list a few hints to help you decide. Please note that especially the tool platform integration doesn\u0026rsquo;t have to be an ultimate decision. Many adopters start deploying for one tool platform, e.g. Eclipse Theia, but add support for VS Code later and offer both options in parallel.\n üñ•Ô∏è Server Whether to use Java or Typescript is a matter of taste. However, there also are objective considerations.\n If you aim at providing a VS Code extension or Theia plugin, shipping a node-based GLSP server is easier, because you don\u0026rsquo;t need to worry whether your users have a JVM installed. They\u0026rsquo;ll have a node runtime already, otherwise they couldn\u0026rsquo;t run VS Code or Theia. If you have more control over your users runtime, e.g. because the editor will run in a container in the cloud anyway, this is less of a concern. Using one language (Typescript) for your GLSP server and client leads to a more homogeneous developer experience than having to work with two languages (Java and Typescript). If you already have an editor implementation in Java, e.g. based on GMF, etc., or an EMF metamodel, building a Java-based server opens lots of opportunities for reusing your existing business logic in the GLSP server. If you want to work with EMF source models directly from your GLSP server, e.g. because you want to benefit from its command stack implementation, change notification support, etc., using Java on the GLSP server is clearly better.  üóÇÔ∏è Source Model The choice of a framework to manage your source model mostly depends on two things:\n Which language do you choose for your GLSP server? This may already remove options, e.g. EMF in a node server, unless you externalize the model management into an own separate component, such as an emf.cloud model server. How do you process those source models later on, e.g. for code generation, interpreting it at runtime, etc. and what in what language those components that process your source model are developed with?  Besides, there are a few more considerations.\n Usually you want to provide undo/redo support. If you use a custom serialization and format, you\u0026rsquo;ll have to implement that yourself. Or are there frameworks available that will do that for you? For Java, EMF is a great choice here. You may want to consider using a database instead of a file. This will externalize much of the model and transaction management for you. However, databases have the disadvantage that they shouldn\u0026rsquo;t be checked into a git repository. So you opt out of a completely file-based approach with that choice. In many use cases, it is advisable to separate the graphical information (such as coordinates) from the \u0026ldquo;semantic\u0026rdquo; information of your model. This way your semantic model will be more concise for later processing. It\u0026rsquo;ll put a slight overhead during editing on top, as you\u0026rsquo;ll need to manage two resources. For EMF, GLSP provides a very simple notation model to capture the graphical information.  More information on the integration components is given in the section on source model integrations.\nüñºÔ∏è Tool Platform The decision for a tool platform has many aspects, such as are you providing a product or a plugin for a generic tool, such as VS Code, are your users already using a certain tool platform, etc.? However, the integration layer of GLSP editors for certain tools is rather thin and it is not much work to provide multiple options here in parallel. So choose what\u0026rsquo;s best for you now, you can easily change or add a tool platform support later.\nMore information on the integration components is given in the section on platform integrations.\n   Package Architecture Depending on your choice of tool platform integration and server framework, a different selection of packages needs to be used. The project templates linked in the getting started guide provide the initial setup of the package architecture for the respective combination of components. However, all of them will have a diagram-specific client package that depends on @glsp/client and a diagram-specific server package that either depends on the node-based GLSP server framework or the Java-based GLSP server framework.\nIrrespectively of the used tool platform integration, server framework or source model integration, your custom glsp-client is always the same and can be reused for all scenarios. Your server implementation is also independent of the respective platform integration and reusable for multiple platforms. Depending on the source model framework, the server may add additional dependencies (e.g. to use the EMF.cloud model server client).\nAs an example, the following figure shows the package architecture for a Theia-based GLSP editor with a node-based server.\n Package overview for node-based server and Theia integration The package your-glsp-client represents your custom client package and your-glsp-server depicts your custom GLSP server package. They contain the diagram-specific implementations for your diagram editor and modeling language.\nPlease note how the your-glsp-client builds upon the @glsp/client and the package your-theia-integration just integrates this as an editor based on @glsp/theia-integration into the Theia tool platform. Your GLSP client and your Theia integration have an indirect dependency to Eclipse Sprotty and its Theia glue code. Both the client and the server share a common package @glsp/protocol that defines the action types.\nServer Frameworks GLSP servers can be written in any language, as they run in a separate process and communicate via JSON-RCP with the client. To make it easier to develop GLSP servers, however, GLSP provides two server frameworks:\n GLSP server framework for Java GLSP server framework for Node  Even though they are built with different runtimes and languages, they are structurally very similar. Both use dependency injection (DI) for hooking up your diagram-specific providers, services, and handlers or for replacing default implementation with customized implementations.\nThe Java-based GLSP server uses Google Guice as a dependency injection framework. With Google Guice, there is one main DI module that contains each binding in a dedicated method. Adopters can extend this module and customize it by overriding dedicated binding methods. The node-based GLSP server uses inversify.js as dependency injection framework.\nFor both servers, GLSP provides dedicated abstract base classes named DiagramModule, which are intended to be extended in order to implement a concrete diagram server. The idea of those abstract base classes is that the abstract methods they contain MUST be implemented in order to show a diagram, e.g. the source model storage and the graphical model factory, and additional methods MAY be overwritten to add functionalities, such as certain editing operations or model validation, or to customize default behavior. There are also pre-configured diagram modules for certain source models, described below, e.g. for EMF or EMF.cloud, which already bind relevant implementations.\nThe remainder of this documentation shows, whenever applicable, a code example for both servers. Also there are project templates for both servers, as listed in the getting started guide, as well as an example server for the common \u0026ldquo;workflow diagram\u0026rdquo;, in each of the server repositories, linked above.\nServer DI Container vs Diagram Session DI Container It is worth noting, that GLSP servers distinguish between two DI containers:\n Server DI Container  The server DI container is used to configure global components and services that are not related to a specific session diagram as well as components that are shared between all session containers. Diagram Session DI Containers  Each client session has a dedicated DI container which holds the session-specific information as well as dedicated instances of handlers, states, etc. Each client session container is associated with a single diagram language and is configured with the corresponding diagram module.  Source Model Integrations GLSP works with any source model format or framework for managing your source model, as the implementation for loading source models and translating them into diagrams needs to be provided by the developer of the diagram editor. However, there are recurring popular choices, for which GLSP provides base modules with default implementations for a specific source model framework.\n Integration for EMF models Integration for EMF models with a separate notation model Integration for EMF.cloud model server Abstract base diagram module for storing and modifying GModels as JSON files directly: Java or node  Platform Integrations GLSP-based editors can be integrated into any web application frame. To ease the platform integration for adopters, however, dedicated glue code frameworks are provided for\n Creating an extension to provide a GLSP editor for Eclipse Theia Creating an extension to provide a GLSP editor for VSCode Creating a plugin to prove a GLSP editor for the Eclipse IDE Creating a standalone GLSP web editor based on plain javascript  In general it is recommended to keep the GLSP diagram implementation separated from the platform integration code by splitting them into separate packages. With that, the core GLSP editor can be easily reused and integrated into another platform.\nAs an example, the GLSP Workflow example provides the GLSP diagram implementation in the @eclipse-glsp/workflow-glsp package. All platform-specific integration examples import this package and provide a small integration package containing the platform-specific glue code on top.\n","permalink":"https://www.eclipse.org/glsp/documentation/integrations/","tags":null,"title":"Servers \u0026 Integrations"},{"categories":null,"contents":"Source Model The source model represents the actual data that is represented in the diagram and that is modified when the user applies changes in the diagram. Typical source model formats are EMF models, JSON files, and databases, etc. However, GLSP and the GLSP server frameworks don\u0026rsquo;t put any restrictions on what the format of this source model is. This is achieved by putting developers of GLSP diagram servers in charge of defining how to load a source model, how to transform it into a graphical model, which is the description of the diagram to be rendered, and how to manipulate the source model, if a user edits a diagram.\nTherefore, a GLSP server needs to provide the following implementations:\n Source model storage, which defines how to load and store source models. Graphical model factory, which defines how the source model is transformed into a graphical model. Edit operation handlers that manipulate the source model, based on user actions performed in the diagram.  Loading Source Models and Showing a Diagram To load a source model and show a diagram, the following steps are performed:\n The client sends a RequestModelAction with a URI or other arguments for identifying a source model to the server The server invokes the source model storage to load the source model identified by the arguments sent by the client The server invokes the graphical model factory to translate the source model into the graphical model The server sends the created graphical model to the client The client renders graphical model  Processing Edit Operations When a user performs an edit operation in the diagram:\n The client sends an operation request to the server The server invokes the registered edit operation handler, which modifies the underlying source model directly The server applies the graphical model factory to the modified source model to create a new graphical model The server sends the created graphical model to the client The client re-renders the diagram according to the new version of the graphical model  As can be seen in the steps above for loading and editing source models, both processes share many steps and are based on the same three custom implementations for particular source models. Thus, by providing these three implementations, any source model format can be supported with GLSP.\nPlease note that GLSP provides generic base implementations for typical source model types.\nSource Model Storage and Model State Every GLSP server needs to provide an implementation of the interface SourceModelStorage. Implementations of this interface are responsible for loading source models from a specific resource, such as an EMF model, a JSON file, or a database, into the GLSP server\u0026rsquo;s model state.\nThe ModelState is the central stateful object within a client session that represents the information about the current state of the original source model. All other services and handlers may access the model state to obtain the required information about the model in order to perform their diagram editing tasks.\nAs you typically need to store custom information that is specific to your model in the model state, you typically also bind a custom implementation that represents your model state. This implementation usually implements the interface GModelState (and extends the base class DefaultGModelState).\nJava GLSP Server protected Class\u0026lt;? extends GModelState\u0026gt; bindGModelState() { return MyModelState.class; }  Node GLSP Server protected override bindModelState(): BindingTarget\u0026lt;ModelState\u0026gt; { return MyModelState; }   Now as we have registered our model state implementation, we can look at the source model loading. First, we need to make the GLSP server aware of your SourceModelStorage implementation, so you have to bind your implementation of the SourceModelStorage interface in the server‚Äôs DI module:\nJava GLSP Server @Override protected Class\u0026lt;? extends SourceModelStorage\u0026gt; bindSourceModelStorage() { return MySourceModelStorage.class; }  Node GLSP Server protected bindModelState(): BindingTarget\u0026lt;ModelState\u0026gt; { return MySourceModelStorage; }   The registered implementation of the source model storage needs to provide two functionalities:\n Loading source models, based on the parameters that are contained in the RequestModelAction, and adding them into the session‚Äôs model state. The implementation mostly depends on where you need to load your source model(s) from and what kind of model(s) you are dealing with (files, XML, JSON, EMF, a database, etc.). Saving the current version of the source model from the GModelState back into its original resource (files, XML, EMF, database, etc.). This method is invoked when the client sends a SaveModelAction.  Java GLSP Server public class MySourceModelStorage implements SourceModelStorage { @Inject protected MyModelState modelState; @Override public void loadSourceModel(final RequestModelAction action) { final String uri = MapUtil.getValue(action.options, \u0026#34;sourceURI\u0026#34;); // load your model from file, EMF, database, etc.  final YourModel model = ‚Ä¶; // add information needed about your model into the model state  modelState.setModel(model); } @Override public void saveSourceModel(final SaveModelAction action) { // get the current version of your model  final YourModel model = modelState.getModel(); // get the information to know where to store your model  final String uri = action.getFileUri().get(); try { // store your model  } catch (IOException e) { LOG.error(e); throw new GLSPServerException(\u0026#34;An error occured while saving the model.\u0026#34;, e); } } }  Node GLSP Server @injectable() export class MySourceModelStorage implements SourceModelStorage { @inject(MyModelState) protected modelState: MyModelState; loadSourceModel(action: RequestModelAction): MaybePromise\u0026lt;void\u0026gt; { const uri = action.options![\u0026#34;sourceURI\u0026#34;]; // load your model from file, EMF, database, etc.  const model = ‚Ä¶; // add information needed about your model into the model state  this.modelState.model=model; } saveSourceModel(action: SaveModelAction): MaybePromise\u0026lt;void\u0026gt; { // get the current version of your model  const model = this.modelState.model; // get the information to know where to store your model  const uri = this.modelState.sourceUri; try { // store your model  } catch (error) { throw new GLSPServerError(`Could not load model from file: ${this.modelState.sourceUri}`, error); } } }   The GLSP Workflow example is an example, in which in which the source model is a JSON file that contains the GModel directly. In such a scenario, you can use the plain GModelState and the JsonFileGModelStorage.\nOnce the source model has been loaded into the model state, the GLSP server invokes the configured GModelFactory to derive the graphical model from the source model and issues model update for the client.\n ‚û°Ô∏è Let\u0026rsquo;s look at how the source model is translated into a graphical model next!\n","permalink":"https://www.eclipse.org/glsp/documentation/sourcemodel/","tags":null,"title":"Source Model \u0026 State"},{"categories":null,"contents":"The graphical model is a serializable description of the diagram to be visualized on the client. It is the central communication artifact between client and server. The server creates the graphical model from an arbitrary source model by invoking a so-called GModelFactory and sends the graphical model to the client. Thus, the client doesn\u0026rsquo;t need to know from which source model it has been generated and how to manipulate the source model. However, the client interprets the graphical model in order to render a visualization of the diagram described in the graphical model.\nGraphical Model Structure The graphical model is composed of elements and edges. Each element or edge has a unique identifier and a type. The graphical model elements are organized in a tree, as defined by the parent-child relationship between elements, with a single root element. The graphical model library consists of several common base classes, such as nodes, ports, labels, compartments, but can be extended with additional properties or even new types, if needed.\nThe graphical model is typically composed of the following elements.\n GModelRoot: Each graphical model must have exactly one root  GShapeElement: A graphical element is represented by a shape with visual bounds (position and size). Note that such elements can be nested based on their parent-child relationship. There are a the following concrete sub-types of shapes:  GNode: Representation of a logical diagram node GPort: Ports are typically children of nodes and serve as connection points for edges GLabel: Representation of a text label GCompartment: A generic container element used for element grouping   GEdge: A diagram edge that connects a source element and a target element (typically nodes or ports).    SModel: Graphical model on the client The default GLSP client uses Sprotty, an SVG-based diagramming framework, to render diagrams. Sprotty uses a model to represent a diagram too \u0026ndash; the so-called SModel. The graphical model of GLSP is based on the SModel and, thus, can be seen as a compatible extension of the Sprotty model.\nAs a naming convention, GLSP uses the S-prefix for model elements on the client to conform to the naming of the Sprotty model. Thus, a node of the graphical model on the GLSP client is called SNode, whereas it is called GNode on the server, the same is true for SEdge / GEdge, etc. Semantically, those elements, however, are equivalent and are exchanged transparently between the server and the client via JSON-RPC.\nGModel: Graphical model on the server The Java-based GLSP server uses EMF to represent and manage the graphical model internally. Note that this is just an internal way of representing the GModel at runtime but doesn‚Äôt mean that adopters need to represent their original source models with EMF too. The GLSP server uses EMF in order to reuse its model management and editing capabilities, its command stack and command-based editing. Therefore, the graphical model is described as an Ecore model and the corresponding Java classes are automatically generated from this model. Using GSON, the GModel is then serialized and deserialized to JSON before it is sent via JSON-RPC to the client.\nThe node-based GLSP server provides a graph model library, which defines the graph model types, such as GNode, GEdge, etc. alongside a builder API to make creating instances more convenient. However, as the node-based GLSP server and the GLSP client are both based on ES6, this graph library is based on graph model definitions that are used on the client.\nGraphical Model Factory After the initial loading of the source model ‚Äì and also after each change of the source model ‚Äì the GLSP server generates a graphical model from the source model in order to define what is to be rendered on the client.\nThe generation of the graphical model from the original source model is the responsibility of the GModelFactory. Therefore, the GModelFactory obtains the source model from the model state and generates a new graphical model from it. Implementations of the GModelFactory are by nature very specific to the source model and the diagram type. Thus, in almost every GLSP editor project, a custom GModelFactory implementation is provided.\nThe only exception are GLSP editors that directly operate on GModels; that is, the GModel is persisted and loaded directly by the registered implementation of the source model storage. In such cases, no transformation from the source model to the GModel needs to be provided as the source model already is the GModel. Thus, the so-called NullImpl of the GModelFactory can be used. An example for such a use case is provided in the GLSP Workflow example.\nFor all other use cases, an implementation of the GModelFactory needs to be provided and registered in the server DI module as follows.\nJava GLSP Server @Override protected Class\u0026lt;? extends GModelFactory\u0026gt; bindGModelFactory() { return MyModelFactory.class; }  Node GLSP Server protected override bindGModelFactory(): BindingTarget\u0026lt;GModelFactory\u0026gt; { return MyModelFactory; }   For the sake of an example, let‚Äôs assume that the source model is a simple list of named entities. Each entity should be visualized as a node with a label, which indicates its name. Then the corresponding ModelFactory could look as follows.\nJava GLSP Server public class MyModelFactory implements GModelFactory { @Inject protected MyModelState modelState; @Override public void createGModel() { List\u0026lt;Entity\u0026gt; entities = modelState.getModel().getEntities(); List\u0026lt;GModelElement\u0026gt; entityNodes = entities.stream().map(entity -\u0026gt; //  new GNodeBuilder(\u0026#34;node:entity\u0026#34;) .layout(\u0026#34;vbox\u0026#34;) .add(new GLabelBuilder() .text(entity.getName()) .build()) .build()) .collect(Collectors.toList()); GGraph newModel = new GGraphBuilder() .id(\u0026#34;entity-graph\u0026#34;) .addAll(entityNodes) .build(); modelState.setRoot(newModel); } }  Node GLSP Server @injectable() export class MyModelFactory implements GModelFactory { @inject(MyModelState) protected modelState: MyModelState; createModel(): void { const entities = this.modelState.getModel().getEntities(); const entityNodes = entities.map(entity =\u0026gt; new GNodeBuilder(GNode).id(\u0026#39;node:entity\u0026#39;).layout(\u0026#39;vbox\u0026#39;) .add(new GLabelBuilder(GLabel) .text(entity.name) .build()) .build() ); const newModel = new GGraphBuilder(GGraph) .id(\u0026#39;entity-graph\u0026#39;) .addChildren(...entityNodes) .build(); this.modelState.root = newModel; } }   In the createGModel() method the entities are retrieved from the model state, as they have been added there by the source model storage (see Source Model Storage). Then a new GNode is created for each entity. Finally all new nodes are added as children of a newly created GGraph and the graphical root element in the model state is updated.\nNote that we have used the GModelBuilder API in this example to construct new graphical elements. This builder API offers a convenient way to construct new graphical model elements in a concise and fluent fashion. It is the preferred method and should be used over plain constructor creation.\nExtending the Graphical Model GLSP provides a set of default graphical model element classes that can be used to construct the graphical model and already cover a large set of use cases. For advanced use cases the existing base model elements can be customized or additional elements can be introduced. As an example, let‚Äôs have a look at the custom WeightedEdge element introduced by the GLSP Workflow example.\nGLSP Client A WeightedEdge is a special edge that has an optional ‚Äúprobability‚Äù property. We can define such an element by simply subclassing the SEdge class:\nexport class WeightedEdge extends SEdge { probability?: string; } And then the new WeightedEdge type has to be configured in the diagram module (di.config.ts).\nconst workflowDiagramModule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { ... configureModelElement(context, \u0026#39;edge:weighted\u0026#39;, WeightedEdge, WorkflowEdgeView); ... }  Node GLSP Server For the node GLSP server the new WeightedEdge type can be declared similar to the GLSP client by subclassing the GEdge class.\nexport class WeightedEdge extends GEdge { probability?: string; } To use the builder API for WeightedEdge creation we also have to implement a WeightedEdgeBuilder that extends the default GEdgeBuilder.\nexport class WeightedEdgeBuilder\u0026lt;E extends WeightedEdge = WeightedEdge\u0026gt; extends GEdgeBuilder\u0026lt;E\u0026gt; { probability(probability: string): this { this.proxy.probability = probability; return this; } }  Java GLSP Server When using the Java GLSP server, a new Ecore model that extends the default \u0026ldquo;graph.ecore\u0026rdquo; model has to be created to declare new model elements. For more details, please have a look at the \u0026ldquo;workflow-graph.ecore\u0026rdquo; model in the GLSP Workflow example. Once the WeightedEdge is specified in the Ecore model, the corresponding source code has to be generated. Now the GraphExtension API can be used to configure the \u0026ldquo;workflow-graph.ecore\u0026rdquo; for the workflow diagram language. A class that implements the the corresponding interface has to created:\npublic class WFGraphExtension implements GraphExtension { @Override public EPackage getEPackage() { return WfgraphPackage.eINSTANCE; } @Override public EFactory getEFactory() { return WfgraphFactory.eINSTANCE; } } And then configured in the WorkflowDiagramModule:\n@Override protected Class\u0026lt;? extends GraphExtension\u0026gt; bindGraphExtension() { return WFGraphExtension.class; } To use the builder API for WeightedEdge creation we also have to implement a WeightedEdgeBuilder that extends the default AbstractGEdgeBuilder. \nGeneric Args Every graphical model element type has a generic ‚Äúargs‚Äù property, which can be used to store additional properties as key-value pairs. These arguments can be used as a more lightweight alternative to extending the graphical model classes, especially if only simple extensions are needed.\n ‚û°Ô∏è Let\u0026rsquo;s look at how the graphical model is rendered on the client next!\n","permalink":"https://www.eclipse.org/glsp/documentation/gmodel/","tags":null,"title":"Graphical Model"},{"categories":null,"contents":"Rendering The input of the diagram rendering on the client is the GModel that has been generated on the server from the source model (see Graphical Model) and sent to the client via a SetModelAction or UpdateModelAction. The client is then responsible for rendering the GModel.\nIn order to render the received graphical model, each graphical element type needs to be associated with a view on the client. A view defines how a specific type of graphical element shall be transformed into a corresponding SVG representation. The derived SVG elements are then rendered on the canvas of the diagram widget.\nTo define a new view, we have to create a class that implements the IView interface and register it for a specific type that is used in the graphical model. As an example, let‚Äôs configure that the view named SLabelView is used for all elements with the type ‚Äúlabel:custom‚Äù. Therefore, we first need to create a dependency injection module, named customDiagramModule below, and configure the SLabelView for the graphical model element type ‚Äúlabel:custom‚Äù using the configureModelElement() utility function:\nconst customDiagramModule= new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { const context = { bind, unbind, isBound, rebind }; configureModelElement(context, \u0026#39;label:custom\u0026#39;, SLabel, SLabelView); }); The configureModeElement() function takes the inversify binding context, the graphical model type, its model class and its associated view as input. Under the hood this function sets up the necessary bindings so that the GLSP client knows that\n Graphical model elements (received from the GLSP Server) with type ‚Äòlabel:custom‚Äô are deserialized to instances of SLabel Graphical model element with type ‚Äòlabel:custom‚Äô are rendered with the SLabelView  In order to be effective, we need to load the module customDiagramModule defined above in the diagram DI container, aka the root \u0026ldquo;di.config.ts\u0026rdquo; of your diagram implementation. With that, every element of type ‚Äúlabel:custom‚Äù will be rendered with the view implementation SLabelView.\nViews themselves are typically implemented with JSX, which simplifies the definition of SVG elements in Typescript. Therefore, the following generic imports are required in any module declaring a view to enable declaration of svg elements with JSX:\n/** @jsx svg */ import { VNode } from \u0026#39;snabbdom\u0026#39;; import { RenderingContext, svg } from ‚Äò@eclipse-glsp/client‚Äô; In addition, make sure that the following options are set in the tsconfig.json file of your project:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;jsx\u0026#34;:\u0026#34;react\u0026#34;, \u0026#34;reactNamespace\u0026#34;:\u0026#34;JSX\u0026#34; } With that, we can implement a view as follows:\n@injectable() export class SLabelView extends ShapeView { render(label: Readonly\u0026lt;SLabel\u0026gt;, context: RenderingContext): VNode | undefined { if (!isEdgeLayoutable(label) \u0026amp;\u0026amp; !this.isVisible(label, context)) { return undefined; } const vnode = \u0026lt;text class-sprotty-label={true}\u0026gt;{label.text}\u0026lt;/text\u0026gt;; const subType = getSubType(label); if (subType) { setAttr(vnode, \u0026#39;class\u0026#39;, subType); } return vnode; } } Every view has to implement the render() method. The render() method takes the graphical model element as input and returns the corresponding SVG element as virtual DOM node. The viewer queries all registered views and creates a new virtual DOM which is then used to patch the current DOM of the diagram widget.\nNote that the SLabelView also checks whether the given element is visible and skips the SVG generation if the element is not visible in the diagram canvas. This check is optional but it‚Äôs highly recommended to implement it in your custom views as it heavily improves the rendering performance. \nStyling The style of the rendered SVG elements is controlled with plain CSS. CSS classes can be declared directly in the corresponding view. The SLabelView, for instance, adds the CSS class ‚Äòsprotty-label‚Äô to the generated SVG text element.\nconst vnode = \u0026lt;text class-sprotty-label={true}\u0026gt;{label.text}\u0026lt;/text\u0026gt;; Graphical model elements also have a ‚ÄòcssClasses‚Äô property which contains a list of CSS classes to be applied, in addition to the classes defined in the view. For instance, the server could send the following graphical model element:\n{ \u0026#34;id\u0026#34;: \u0026#34;myCustomLabel\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;label:custom\u0026#34;, \u0026#34;cssClasses\u0026#34;:[ \u0026#34;my-custom-class\u0026#34; ] } Keeping our previous model configuration in mind, the corresponding SVG element now has two css classes applied: ‚Äòsprotty-label‚Äô and ‚Äòmy-custom-class‚Äô.\nBased on those CSS classes, we can define CSS rules:\n.sprotty-label { fill: black; font-size: 100%; } .my-custom-class.sprotty-label { fill: red; } This simple style sheet declares that elements with the class ‚Äòsprotty-label‚Äô‚Äô should be rendered in black. If ‚Äúmy-custom-class‚Äô‚Äô is applied as well they are rendered in red. To load this stylesheet it has to be imported somewhere in the project. Typically this is done in the \u0026ldquo;di.config.ts‚Äù file as it‚Äôs the entry point of the diagram DI container.\nimport \u0026#39;../css/diagram.css\u0026#39;; const customDiagramModule= new ContainerModule((bind,unbind, isBound,rebind)=\u0026gt;{ ‚Ä¶ });  ‚û°Ô∏è Now it\u0026rsquo;s best to learn more about client-side layouting next!\n","permalink":"https://www.eclipse.org/glsp/documentation/rendering/","tags":null,"title":"Rendering \u0026 Styling"},{"categories":null,"contents":"We distinguish between micro and macro layout. Usually, the server is responsible for the macro layout, that is the arrangement of the main model elements (i.e. nodes and edges). This layout is defined already in the graphical model by means of coordinates. In turn, the client is responsible for the micro layout, that is the positioning and size computation of elements within a container element such as nodes. The client side (i.e. micro) layout can be configured in the graphical model, but will be applied on the client during the rendering phase. \nLayout Container Graphical elements that support client-side layouting of contained elements offer a layout property which defines the type of layouter that should be used. In addition, the behavior of the layouter can be configured with layout options.\nFor an example let‚Äôs have a look at the following GNode:\n Java GLSP Server new GNodeBuilder() .layout(\u0026#34;vbox\u0026#34;) .layoutOptions(new GLayoutOptions() .hAlign(\u0026#34;center\u0026#34;)) .add(new GLabelBuilder() .text(\u0026#34;label1\u0026#34;) .build()) .add(new GLabelBuilder() .text(\u0026#34;label2\u0026#34;) .build()) .build();   Node GLSP Server GNode.builder() .layout(\u0026#39;vbox\u0026#39;) .addLayoutOption(\u0026#39;hAlign\u0026#39;, \u0026#39;center\u0026#39;) .add(new GLabelBuilder(GLabel).text(\u0026#39;label1\u0026#39;).build()) .build();   This node contains two label elements that should be layouted. There are four built-in layout types that can be used: ‚Äúhbox‚Äù,‚Äùvbox‚Äù,‚Äùstack‚Äù and ‚Äúfreeform‚Äù. In the example node we define that the labels should be layouted with the vbox layouter. In addition, we specify options for that layouter by defining that the children should be centered horizontally.\nAdditional layouters can be contributed by creating a layouter class that implements the ILayout interface.\nGLSP Client export interface ILayout { layout(container: SParentElement \u0026amp; LayoutContainer, layouter: StatefulLayouter): void }  Then the new custom layout needs to bound in the diagram module (\u0026ldquo;di.config.ts\u0026rdquo;):\nGLSP Client const myDiagramMdoule = new ContainerModule((bind, unbind, isBound, rebind) =\u0026gt; { bind(TYPES.Layouter).to(MyCustomLayouter); }   Edge Layout Graphical elements that are typically rendered in combination with an edge such as labels have an edgeLayout property. This can be used to describe how the element should be aligned with the edge.\nFor example let\u0026rsquo;s have a look at the following GLabel:\n Java GLSP Server new GLabelBuilder() //  .edgePlacement(new GEdgePlacementBuilder()//  .side(\u0026#34;top\u0026#34;)//  .position(0.5)//  .build())//  .add(new GLabelBuilder().text(\u0026#34;MyLabel\u0026#34;).build()) .build();   Node GLSP Server GLabel.builder() .edgePlacement({ side: \u0026#39;top\u0026#39;, position: 0.5, rotate: false, offset: 0 }) .add(new GLabelBuilder(GLabel).text(\u0026#39;MyLabel\u0026#39;).build()) .build();   The label above specifies the property edgePlacement. If this label is added as a child of an edge, it will be placed above the edge. The position is defined with 0.5 (i.e. 50 percent of the edge length) which means the label should be placed in the center of the edge. After the edge routes have been rendered the client will query all active edge placements and adjust the label position accordingly.\n","permalink":"https://www.eclipse.org/glsp/documentation/clientlayouting/","tags":null,"title":"Client-side Layouting"},{"categories":null,"contents":"Overview The client and the server communicate bidirectionally by sending actions via JSON-RPC. In addition, they are also used for the internal event flow in both the GLSP server and the GLSP client. Any service, mouse tool, etc. can issue actions by invoking the action dispatcher, either on the client or the server.\nThe action dispatcher ‚Äì there is one on the client and one on the server ‚Äì is the central component responsible for dispatching actions to their designated action handlers.\nWhen the dispatcher receives a new action for dispatching, it determines whether it should be dispatched to the internal action handlers only or submitted to the opposite component via JSON-RCP (server or client), based on the registered handlers on the server or the client.\nThe dispatcher distinguishes between notifications and request-response action pairs. Notification actions are one-way actions transferred between client and server. This means when the action dispatcher dispatches a notification it does not wait for a response and directly continues with dispatching the next incoming action. Request actions are typically issued by the GLSP client and can be used to block client-side action dispatching until the server has sent a corresponding response action.\nGLSP defines the standard action types of the graphical language server protocol. However, adopters can add new custom action types. Besides, adopters can replace and extend existing, or add additional action handlers for standard or custom action types.\nTo do that the following steps have to be performed:\n Create a new action specification by providing a corresponding Action implementation Create a new action handler for the newly created action type by providing a implementation of the ActionHandler interface Configure the new action type and handler in the DI module.  Action specification Adopters can declare new custom actions by providing an implementation for the Action interface (resp. base class).\nJava GLSP Server public class MyCustomAction extends Action { public static final String KIND= \u0026#34;myCustomKind\u0026#34;; private String additionalInformation; public MyCustomAction() { super(KIND); } public String getAdditionalInformation() { return additionalInformation; } public void setAdditionalInformation(final String additionalInformation) { this.additionalInformation = additionalInformation; } }  GLSP Client/Node GLSP Server export class MyCustomAction implements Action { static readonly KIND = \u0026#39;myCustomKind\u0026#39;; kind = MyCustomAction.KIND; constructor(public readonly additionalInformation: string) { } }   Each action specification has a unique ‚Äúkind‚Äù and can optionally declare additional data properties. We recommend defining the action kind as a static constant of the implementing class so that it can be accessed from other places, e.g. when registering the handler. Note that action instances need to be serializable to JSON. Therefore the class should only contain plain data properties and no additional business logic. In addition, references to graphical model elements should be done by id.\nIf an action is interchanged between client and server both need to provide the corresponding action definition.\nRequest-Response Actions If the client should be able to dispatch the new action as a blocking request, the action specification class has to implement or extend RequestAction.\nJava GLSP Server public class MyCustomRequestAction extends RequestAction\u0026lt;MyCustomResponseAction\u0026gt; { public static final String KIND= \u0026#34;myCustomRequest\u0026#34;; private String additionalInformation; public MyCustomRequestAction() { super(\u0026#34;my.custom.kind\u0026#34;); } public String getAdditionalInformation() { return additionalInformation; } public void setAdditionalInformation(final String additionalInformation) { this.additionalInformation = additionalInformation; } }  GLSP Client/Node GLSP Server export class MyCustomRequestAction implements RequestAction\u0026lt;MyCustomResponseAction\u0026gt; { static readonly KIND = \u0026#39;myCustomRequest\u0026#39;; kind = MyCustomRequestAction.KIND; constructor(public readonly additionalInformation: string, public readonly requestId = \u0026#39;\u0026#39;) {} }   Each request action has a ‚ÄúrequestId‚Äù and defines its response action as a type parameter. Of course, the response action specification has to be specified as well:\nJava GLSP Server public class MyCustomResponseAction extends ResponseAction { public static final String KIND = \u0026#34;myCustomResponse\u0026#34;; public MyCustomResponseAction() { super(KIND); } }  GLSP Client/Node GLSP Server export class MyCustomResponseAction implements ResponseAction { static readonly KIND = \u0026#39;myCustomResponse\u0026#39;; kind = MyCustomResponseAction.KIND; constructor(public responseId = \u0026#39;\u0026#39;) {} }   The client can dispatch a request action either in blocking fashion awaiting the response:\n@inject(TYPES.IActionDispatcher) protected actionDispatcher: GLSPActionDispatcher; ‚Ä¶ const response = await this.actionDispatcher.request(new MyCustomRequestAction(‚Äúinfo‚Äù)); // response is of type MyCustomResponseAction or simply dispatch the action as non-blocking notification:\n@inject(TYPES.IActionDispatcher) protected actionDispatcher: GLSPActionDispatcher; ‚Ä¶ this.actionDispatcher.dispatch(new MyCustomRequestAction(‚Äúinfo‚Äù)); Response actions don‚Äôt necessarily have to be part of a response-request action pair and can also be dispatched without a preceding request action. \nImplementing an Action Handler (GLSP Server) To create a new action handler, a class that implements the ActionHandler interface has to be created. In general, an action handler can handle one or more action kinds. However, handling multiple action kinds is typically reserved for rather uncommon edge cases. Therefore, the Java GLSP server provides an abstract base class that is designed for the single-action-kind-per-hanlder use case.\nJava GLSP Server public class MyCustomActionHandler extends AbstractActionHandler\u0026lt;MyCustomResponseAction\u0026gt; { @Override protected List\u0026lt;Action\u0026gt; executeAction(final MyCustomResponseAction actualAction) { // implement your custom logic to handle the action  // Finally issue response actions  // If no response actions should be issued \u0026#39;none()\u0026#39; can be used;  return listOf(new MyCustomResponseAction()); } }  Node GLSP Server @injectable() export class MyCustomActionHandler implements ActionHandler { actionKinds = [MyCustomRequestAction.KIND]; execute(action: MyCustomRequestAction): MaybePromise\u0026lt;Action[]\u0026gt; { // implement your custom logic to handle the action  // Finally issue response actions  // If no response actions should be issued \u0026#39;[]\u0026#39; can be used;  return [new MyCustomResponseAction()]; } }   The executeAction() method has to be implemented to provide the custom logic of your action handler. It returns a set of response actions that should be dispatched after the handler execution.\nNext, the custom handler has to be configured in the DiagramModule:\nJava GLSP Server @Override protected void configureActionHandlers(final MultiBinding\u0026lt;ActionHandler\u0026gt; binding) { super.configureActionHandlers(binding); binding.add(MyCustomActionHandler.class); }  Node GLSP Server protected override configureActionHandlers(binding: InstanceMultiBinding\u0026lt;ActionHandlerConstructor\u0026gt;): void { super.configureActionHandlers(binding); binding.add(MyCustomActionHandler); }   In addition, each response action of the handler that should be handled by the GLSP client has to be configured as dedicated client action to indicate that it needs to be dispatched to the client:\nJava GLSP Server protected void configureClientActions(final MultiBinding\u0026lt;Action\u0026gt; binding) { super.configureClientAction(binding); binding.add(MyCustomRequestAction.class); }  Node GLSP Server protected configureClientActions( binding: InstanceMultiBinding\u0026lt;string\u0026gt; ): void { super.configureClientActions(binding); binding.add(MyCustomRequestAction.KIND); }   Request-Response Handling Action handlers can treat request-response actions in the same way as plain actions. No special handling is required. The action dispatcher tracks all incoming request actions and automatically intercepts the corresponding response action to set the correct response id. \nImplementing an Action Handler (GLSP Client) On the client, GLSP reuses the IActionHandler API of Sprotty. Therefore, to create a new action handler, a class that implements the IActionHandler interface has to be created.\n@injectable() export class MyCustomResponseActionHandler implements IActionHandler{ handle(action: MyCustomResponseAction): void | Action { // implement your custom logic to handle the action  // Optionally issue a response action  } } The handle() method has to be implemented to provide the custom logic of your action handler. It optionally returns a response action that should be dispatched after the handler execution.\nA dedicated configuration function is available to configure the new action handler in the diagram module (‚Äúdi.config.ts‚Äù):\nconst diagramModule = new ContainerModule((bind, _unbind, isBound, rebind) =\u0026gt; { const context = { bind, _unbind, isBound, rebind }; configureActionHandler(context, MyCustomResponseAction.KIND, MyCustomResponseActionHandler); } The configureActionHandler() function takes the inversify binding context, the action kind that should be handled, and the action handler class, as input. It registers the action handler for the given action kind, so that it can be retrieved by the action dispatcher.\nNote that we don‚Äôt have to explicitly declare which actions are handled by the GLSP Server. The GLSP server sends this information during the initialization process and the GLSP client automatically sets up the necessary action (handler) registrations.\n","permalink":"https://www.eclipse.org/glsp/documentation/actionhandler/","tags":null,"title":"Actions \u0026 Action Handler"},{"categories":null,"contents":"This section is currently work in progress.\n","permalink":"https://www.eclipse.org/glsp/documentation/modeloperations/","tags":null,"title":"Model Operations"},{"categories":null,"contents":"Validation rules for the source and/or graphical model are typically implemented on the GLSP server, as only the server has the full knowledge of the underlying model. Model validation rules are by nature specific to the underlying modeling language and therefore have to be provided by the specific server implementation. The interface to be implemented is called ModelValidator. The ModelValidator is invoked for a set of model elements and creates issue markers for them.\nIn many scenarios, the ModelValidator implementation delegates to another component, such as EMF validation, etc.\nLet\u0026rsquo;s have a look at a simple example implementation of a model validator:\nJava Server public class CustomModelValidator implements ModelValidator { @Override public List\u0026lt;Marker\u0026gt; validate(final GModelElement... elements) { List\u0026lt;Marker\u0026gt; markers = new ArrayList\u0026lt;\u0026gt;(); for (GModelElement element : elements) { if (element instanceof GNode) { markers.add(validateGNode((GNode) element)); } element.getChildren().forEach(child -\u0026gt; markers.addAll(validate(child))); } return markers; } protected Marker validateGNode(final GNode element) { return new Marker(\u0026#34;Node\u0026#34;, \u0026#34;This graphical element is a node\u0026#34;, element.getId(), MarkerKind.INFO); } }  Node Server @injectable() export class CustomModelValidator implements ModelValidator { @inject(GModelState) protected readonly modelState: GModelState; validate(elements: GModelElement[]): Marker[] { const markers: Marker[] = []; for (const element of elements) { if (element instanceof GNode) { markers.push(this.validateGNode(element)); } if (element.children) { markers.push(...this.validate(element.children)); } } return markers; } protected validateGNode(element: GNode): Marker { return { kind: MarkerKind.INFO, description: \u0026#39;This graphical element is a node\u0026#39;, elementId: element.id, label: \u0026#39;Node\u0026#39; }; } }   This validator iterates over the given model elements and their children and creates a new info marker for each element that is an instance of GNode. An issue marker is associated with a graphical element via its ‚Äúid‚Äù. In addition, the marker has a label, an issue description and a kind indicating its severity. The severity can either be ‚ÄúINFO‚Äù,‚ÄùWARN‚Äù or ‚ÄúERROR‚Äù. The created markers are then propagated to the client via a SetMarkersAction.\nTo enable the custom model validator, it has to be bound in the diagram module.\nJava Server @Override protected Class\u0026lt;? extends ModelValidator\u0026gt; bindModelValidator() { return CustomModelValidator.class; }  Node Server protected override bindModelValidator(): BindingTarget\u0026lt;ModelValidator\u0026gt; | undefined { return CustomModelValidator; }   Validation is typically triggered by the client via a RequestMarkersAction ‚Äì e.g., by clicking the validation button in the tool palette. In addition, the server can also send a SetMarkersAction to the client without a preceding request at any time. This is useful to implement features such as automatic live validation after each model update.\nThe client visualizes each marker by decorating the corresponding graphical element with an icon indicating the severity. When hovering over the issue marker a tooltip with the issue description is displayed.\nDepending on the chosen platform integration, validation markers are propagated to other user interface components. For instance, when integrating GLSP into Theia, markers are also translated into items shown in the Problems view.\n","permalink":"https://www.eclipse.org/glsp/documentation/validation/","tags":null,"title":"Model Validation"},{"categories":null,"contents":"Articles  An introduction to the Graphical Language Server Protocol/Platform (Eclipse GLSP) Web-based diagram editor features in Eclipse GLSP GLSP: Diagrams in VS Code, Theia, Eclipse and plain HTML Diagram editors in Theia and VS Code with Eclipse GLSP A diagram editor framework for VS Code A hands-on tutorial for Eclipse GLSP A minimal diagram editor example for Eclipse GLSP Building diagram editors in Eclipse Theia with GLSP The workflow diagram example for Eclipse GLSP A web-based modeling tool based on Eclipse Theia and GLSP  Videos  EclipseCon 2021: Diagram editors with Eclipse GLSP - 1.0 Cloud Tool Time: Diagram editors in Theia and VSCode with Eclipse GLSP EclipseCon 2020: Diagram editors in the web with Eclipse GLSP EclipseCon 2020: Ecore tools in the cloud - behind the scenes EclipseCon 2020: Web-based modeling tools with EMF.cloud and GLSP Eclipse Virtual Meet Up 2019: Diagrams in web and space with GLSP EclipseCon 2019: Diagrams in web and space with GLSP EclipseCon Europe 2018: Towards a Graphical Language Server Protocol for Diagrams?  ","permalink":"https://www.eclipse.org/glsp/documentation/additionals/","tags":null,"title":"More Articles \u0026 Videos"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/categories/","tags":null,"title":"Categories"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/documentation/","tags":null,"title":"Documentation"},{"categories":null,"contents":"An example GLSP diagram including one GLSP server and several diagram client integrations (VS Code, Eclipse Theia, plain HTML and Eclipse desktop IDE). The example can be used to try out the GLSP features in a running version. Most components of GLSP, such as the GLSP server framework or the Theia integration implement the workflow diagram as a consistent example. As the example is fully open source, you can use the example as a blueprint for a custom implementation of a GLSP diagram. The example diagram is a simplified flow chart with different types of nodes and edges (see screen shot below)  To launch/browse the example, please use the links below leading to the components of the workflow diagram example. You will need the workflow GLSP server (there is only one) and at least one client integration (select the one you are interested in). Launch the server first and then the client of your choice to try the example. Alternativly, you can try the workflow example online embedded into an example tool (see last option below) ","permalink":"https://www.eclipse.org/glsp/examples/","tags":null,"title":"Examples"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/gallery/","tags":null,"title":"Gallery"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/","tags":null,"title":"GLSP"},{"categories":null,"contents":"Support for GLSP and for projects adopting GLSP is provided by ","permalink":"https://www.eclipse.org/glsp/support/","tags":null,"title":"Support"},{"categories":null,"contents":null,"permalink":"https://www.eclipse.org/glsp/tags/","tags":null,"title":"Tags"}]